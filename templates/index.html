<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SailBay - Boats & Sailing Gear</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon">
    <!-- Leaflet CSS for map -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        :root {
            --primary-color: #1e5a8e;
            --secondary-color: #f0f8ff;
            --accent-color: #FF6B35;
            --text-color: #2c3e50;
            --ocean-blue: #006994;
            --wave-color: #4a90e2;
            --bg-color: #ffffff;
            --card-bg: #ffffff;
            --border-color: #e9ecef;
        }

        /* Dark Mode - Ocean Night Theme */
        [data-theme="dark"] {
            --primary-color: #4a90e2;
            --secondary-color: #0a1929;
            --accent-color: #FF8C5A;
            --text-color: #e0e0e0;
            --ocean-blue: #1e5a8e;
            --wave-color: #2c5f8d;
            --bg-color: #0d1b2a;
            --card-bg: #1b2838;
            --border-color: #2d3748;
        }
        
    /* Map styling */
        #locationMap {
            z-index: 1;
        }
        
        [data-theme="dark"] .leaflet-tile {
            filter: brightness(0.6) invert(1) contrast(3) hue-rotate(200deg) saturate(0.3) brightness(0.7);
        }
        
        [data-theme="dark"] .leaflet-popup-content-wrapper {
            color: var(--text-color);
        }
        
        [data-theme="dark"] .leaflet-popup-tip {
            background-color: var(--card-bg);
        }

        body {
            background-color: var(--secondary-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .hero-section {
            position: relative;
            color: white;
            padding: 80px 0;
            margin-bottom: 40px;
            border-bottom: 3px solid var(--accent-color);
            overflow: hidden;
        }
        /* Ocean canvas as hero background */
        .hero-section #oceanCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        .hero-section::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(rgba(0,0,0,0.25), rgba(0,0,0,0.45));
            z-index: 1;
        }
        .hero-section .container { position: relative; z-index: 2; }
        [data-theme="dark"] .hero-section::after { background: linear-gradient(rgba(0,0,0,0.45), rgba(0,0,0,0.65)); }

        .weather-widget {
            color: var(--text-color) !important;
        }
        .weather-widget h4,
        .weather-widget .fw-bold,
        .weather-widget .text-muted {
            color: var(--text-color) !important;
        }

        .listing-card {
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            padding: 15px;
            transition: transform 0.2s, background-color 0.3s ease;
            position: relative;
            display: flex;
            flex-direction: column;
            height: 100%;
            border: 1px solid var(--border-color);
        }

        .listing-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .listing-card .description-text {
            min-height: 48px;
            margin-bottom: 10px;
        }
        
        .listing-card .seller-info {
            margin-top: auto;
        }

        .price {
            color: var(--primary-color);
            font-size: 1.25rem;
            font-weight: bold;
        }

        .seller-info {
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .seller-name {
            font-weight: bold;
            color: var(--text-color);
        }

        .rating {
            color: #f39c12;
            margin-left: 5px;
        }

        .btn-primary {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }
        
        .btn-primary:hover {
            background-color: var(--ocean-blue);
            border-color: var(--ocean-blue);
        }

        .out-of-stock-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #dc3545;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.85rem;
            font-weight: bold;
        }

        .category-card {
            cursor: pointer;
            border: 2px solid var(--border-color);
            background: var(--card-bg);
            transition: all 0.3s ease;
        }

        .category-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-color: var(--primary-color);
        }

        .category-card h6 {
            margin: 0;
            color: var(--text-color);
            font-weight: 600;
        }

        .stats-section {
            background: var(--card-bg);
            padding: 40px 0;
            margin: 40px 0;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid var(--border-color);
            transition: background-color 0.3s ease;
        }

        .stat-item {
            text-align: center;
            padding: 20px;
        }

        .stat-number {
            font-size: 2.5rem;
            font-weight: bold;
            color: var(--primary-color);
        }

        .stat-label {
            color: #6c757d;
            font-size: 1rem;
            margin-top: 5px;
        }

        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            .hero-section {
                padding: 40px 0;
            }

            .display-4 {
                font-size: 2rem;
            }

            .lead {
                font-size: 1rem;
            }

            .btn-lg {
                font-size: 1rem;
                padding: 0.5rem 1rem;
            }

            .stat-number {
                font-size: 2rem;
            }

            .stat-label {
                font-size: 0.9rem;
            }

            .category-card {
                margin-bottom: 15px;
            }

            .listing-card {
                padding: 12px;
            }

            .price {
                font-size: 1.1rem;
            }
        }

        @media (max-width: 576px) {
            .hero-section {
                padding: 30px 0;
            }

            .display-4 {
                font-size: 1.75rem;
            }

            .d-flex.gap-3 {
                flex-direction: column;
                gap: 10px !important;
            }

            .d-flex.gap-3 .btn {
                width: 100%;
            }

            .stat-number {
                font-size: 1.75rem;
            }

            .stats-section,
            .container > .row {
                padding: 20px 10px;
            }
        }

        /* Ocean visualization (when in standalone section) */
        .ocean-section {
            position: relative;
            margin: 30px 0 10px 0;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid var(--border-color);
            background: linear-gradient(180deg, rgba(0, 105, 148, 0.8) 0%, rgba(0, 105, 148, 0.95) 100%);
        }
        .ocean-section #oceanCanvas {
            width: 100%;
            height: 260px;
            display: block;
        }
        .ocean-overlay {
            position: absolute;
            top: 12px;
            left: 16px;
            color: #ffffff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.6);
            z-index: 2;
        }
        .ocean-overlay h5 {
            margin: 0 0 2px 0;
            font-weight: 700;
        }
        .ocean-overlay small {
            opacity: 0.9;
        }
        .ocean-tooltip {
            position: absolute;
            padding: 6px 10px;
            background: rgba(255,255,255,0.95);
            color: #1b2838;
            border-radius: 6px;
            font-size: 0.85rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            pointer-events: none;
            transform: translate(-50%, -120%);
            white-space: nowrap;
            border: 1px solid var(--border-color);
            z-index: 10;
        }
        [data-theme="dark"] .ocean-tooltip {
            background: rgba(27, 40, 56, 0.98);
            color: var(--text-color);
            border-color: #203040;
        }
    </style>
</head>
<body>
    {% include 'navbar.html' %}

    <div class="hero-section">
        <canvas id="oceanCanvas" aria-hidden="true"></canvas>
        <div class="container">
            <div class="row justify-content-center">
                <div class="col-md-8 text-center">
                    <h1 class="display-4 mb-4">Discover Boats & Sailing Gear</h1>
                    <p class="lead mb-4">Buy and sell sailboats, parts, rigging, safety equipment, and marine accessories.</p>
                    
                    <!-- Search Bar -->
                    <form action="{{ url_for('products') }}" method="get" class="mb-4">
                        <div class="input-group input-group-lg" style="max-width: 600px; margin: 0 auto;">
                            <input name="search" class="form-control" type="search" placeholder="Search for items..." aria-label="Search" value="{{ request.args.get('search','') }}">
                            <button class="btn btn-primary" type="submit">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-search" viewBox="0 0 16 16">
                                    <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
                                </svg>
                                Search
                            </button>
                        </div>
                    </form>
                    
                    <div class="d-flex justify-content-center gap-3 mb-5">
                        <a href="{{ url_for('products') }}" class="btn btn-primary btn-lg">Browse Listings</a>
                        {% if current_user_is_seller %}
                            <a href="{{ url_for('post_ad') }}" class="btn btn-outline-primary btn-lg">Post an Ad</a>
                        {% else %}
                            <a href="{{ url_for('register') }}" class="btn btn-outline-primary btn-lg">Post an Ad</a>
                        {% endif %}
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Sailing Conditions Widget -->
        <div class="container" style="position: relative; z-index: 2; margin-top: 3rem;">
            <div class="weather-widget mb-5 p-4" style="
                background: linear-gradient(135deg, rgba(13, 110, 253, 0.015) 0%, rgba(25, 135, 84, 0.015) 100%);
                backdrop-filter: blur(6px);
                border-radius: 16px; 
                box-shadow: 
                    0 8px 32px rgba(0, 0, 0, 0.12),
                    0 2px 8px rgba(0, 0, 0, 0.08),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.12);
                transition: all 0.3s ease;
                position: relative;
                overflow: hidden;
            ">
                <!-- Decorative background pattern -->
                <div style="
                    position: absolute;
                    top: -50%;
                    right: -20%;
                    width: 400px;
                    height: 400px;
                    background: radial-gradient(circle, rgba(13, 110, 253, 0.02) 0%, transparent 70%);
                    border-radius: 50%;
                    pointer-events: none;
                "></div>
                <div style="position: relative; z-index: 1;">
                <div class="row align-items-center">
                    <div class="col-md-8">
                        <h4 class="mb-3">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-wind me-2" viewBox="0 0 16 16" style="vertical-align: -3px;">
                                <path d="M12.5 2A2.5 2.5 0 0 0 10 4.5a.5.5 0 0 1-1 0A3.5 3.5 0 1 1 12.5 8H.5a.5.5 0 0 1 0-1h12a2.5 2.5 0 0 0 0-5zm-7 1a1 1 0 0 0-1 1 .5.5 0 0 1-1 0 2 2 0 1 1 2 2h-5a.5.5 0 0 1 0-1h5a1 1 0 0 0 0-2zM0 9.5A.5.5 0 0 1 .5 9h10.042a3 3 0 1 1-3 3 .5.5 0 0 1 1 0 2 2 0 1 0 2-2H.5a.5.5 0 0 1-.5-.5z"/>
                            </svg>
                            Today's Sailing Conditions
                        </h4>
                        <div class="row g-3">
                            <div class="col-md-4">
                                <div class="d-flex align-items-center">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" class="bi bi-thermometer-half me-3 text-primary" viewBox="0 0 16 16">
                                        <path d="M9.5 12.5a1.5 1.5 0 1 1-2-1.415V6.5a.5.5 0 0 1 1 0v4.585a1.5 1.5 0 0 1 1 1.415z"/>
                                        <path d="M5.5 2.5a2.5 2.5 0 0 1 5 0v7.55a3.5 3.5 0 1 1-5 0V2.5zM8 1a1.5 1.5 0 0 0-1.5 1.5v7.987l-.167.15a2.5 2.5 0 1 0 3.333 0l-.166-.15V2.5A1.5 1.5 0 0 0 8 1z"/>
                                    </svg>
                                    <div>
                                        <div class="text-muted small">Temperature</div>
                                        <div class="fw-bold" id="weather-temp">Loading...</div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="d-flex align-items-center">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" class="bi bi-wind me-3 text-primary" viewBox="0 0 16 16">
                                        <path d="M12.5 2A2.5 2.5 0 0 0 10 4.5a.5.5 0 0 1-1 0A3.5 3.5 0 1 1 12.5 8H.5a.5.5 0 0 1 0-1h12a2.5 2.5 0 0 0 0-5zm-7 1a1 1 0 0 0-1 1 .5.5 0 0 1-1 0 2 2 0 1 1 2 2h-5a.5.5 0 0 1 0-1h5a1 1 0 0 0 0-2zM0 9.5A.5.5 0 0 1 .5 9h10.042a3 3 0 1 1-3 3 .5.5 0 0 1 1 0 2 2 0 1 0 2-2H.5a.5.5 0 0 1-.5-.5z"/>
                                    </svg>
                                    <div>
                                        <div class="text-muted small">Wind Speed</div>
                                        <div class="fw-bold" id="weather-wind">Loading...</div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="d-flex align-items-center">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" class="bi bi-cloud-sun me-3 text-primary" viewBox="0 0 16 16">
                                        <path d="M7 8a3.5 3.5 0 0 1 3.5 3.555.5.5 0 0 0 .624.492A1.503 1.503 0 0 1 13 13.5a1.5 1.5 0 0 1-1.5 1.5H3a2 2 0 1 1 .1-3.998.5.5 0 0 0 .51-.375A3.502 3.502 0 0 1 7 8zm4.473 3a4.5 4.5 0 0 0-8.72-.99A3 3 0 0 0 3 16h8.5a2.5 2.5 0 0 0 0-5h-.027z"/>
                                        <path d="M10.5 1.5a.5.5 0 0 0-1 0v1a.5.5 0 0 0 1 0v-1zm3.743 1.964a.5.5 0 1 0-.707-.707l-.708.707a.5.5 0 0 0 .708.708l.707-.708zm-7.779-.707a.5.5 0 0 0-.707.707l.707.708a.5.5 0 1 0 .708-.708l-.708-.707zm1.734 3.374a2 2 0 1 1 3.296 2.198c.199.281.372.584.516.898a3 3 0 1 0-4.84-3.225c.352.011.696.055 1.028.129zm4.484 4.074c.6.215 1.125.59 1.522 1.072a.5.5 0 0 0 .039-.742l-.707-.707a.5.5 0 0 0-.854.377zM14.5 6.5a.5.5 0 0 0 0 1h1a.5.5 0 0 0 0-1h-1z"/>
                                    </svg>
                                    <div>
                                        <div class="text-muted small">Conditions</div>
                                        <div class="fw-bold" id="weather-condition">Loading...</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-4 text-center">
                        <div id="weather-icon" class="mb-2" style="font-size: 64px;">⛵</div>
                        <p class="text-muted mb-2 small" id="weather-location">Getting location...</p>
                        <button id="change-location-btn" class="btn btn-sm btn-outline-primary mb-2" onclick="showLocationModal()">
                            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-geo-alt me-1" viewBox="0 0 16 16" style="vertical-align: -2px;">
                                <path d="M12.166 8.94c-.524 1.062-1.234 2.12-1.96 3.07A31.493 31.493 0 0 1 8 14.58a31.481 31.481 0 0 1-2.206-2.57c-.726-.95-1.436-2.008-1.96-3.07C3.304 7.867 3 6.862 3 6a5 5 0 0 1 10 0c0 .862-.305 1.867-.834 2.94zM8 16s6-5.686 6-10A6 6 0 0 0 2 6c0 4.314 6 10 6 10z"/>
                                <path d="M8 8a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0 1a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
                            </svg>
                            Change Location
                        </button>
                        <p class="text-muted mb-0 small">
                            <span id="sailing-condition-badge" class="badge bg-success">Good Sailing</span>
                        </p>
                    </div>
                </div>
            </div>
        </div>
        </div>
        
        <div id="oceanTooltip" class="ocean-tooltip" style="display:none;"></div>
        <div id="popularProductsData" data-products='{{ popular_products|tojson|safe }}' hidden></div>
    </div>

    <div class="container">
        
        <!-- Location Modal -->
        <div class="modal fade" id="locationModal" tabindex="-1" aria-labelledby="locationModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content" style="background: var(--card-bg); color: var(--text-color);">
                    <div class="modal-header">
                        <h5 class="modal-title" id="locationModalLabel">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-geo-alt-fill me-2" viewBox="0 0 16 16">
                                <path d="M8 16s6-5.686 6-10A6 6 0 0 0 2 6c0 4.314 6 10 6 10zm0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6z"/>
                            </svg>
                            Set Your Location
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="row">
                            <!-- Left side: Search -->
                            <div class="col-md-5">
                                <div class="mb-3">
                                    <label for="citySearch" class="form-label fw-bold">Search Location:</label>
                                    <input type="text" class="form-control" id="citySearch" placeholder="Enter city or marina name...">
                                    <small class="text-muted">Try: Sydney, Newport RI, San Diego, Key West</small>
                                </div>
                                <div class="mb-3">
                                    <button class="btn btn-secondary w-100" onclick="useCurrentLocation()">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-crosshair me-2" viewBox="0 0 16 16">
                                            <path d="M8.5.5a.5.5 0 0 0-1 0v.518A7.001 7.001 0 0 0 1.018 7.5H.5a.5.5 0 0 0 0 1h.518A7.001 7.001 0 0 0 7.5 14.982v.518a.5.5 0 0 0 1 0v-.518A7.001 7.001 0 0 0 14.982 8.5h.518a.5.5 0 0 0 0-1h-.518A7.001 7.001 0 0 0 8.5 1.018V.5zm-6.48 7A6.001 6.001 0 0 1 7.5 2.02v.48a.5.5 0 0 0 1 0v-.48a6.001 6.001 0 0 1 5.48 5.48h-.48a.5.5 0 0 0 0 1h.48a6.001 6.001 0 0 1-5.48 5.48v-.48a.5.5 0 0 0-1 0v.48A6.001 6.001 0 0 1 2.02 8.5h.48a.5.5 0 0 0 0-1h-.48z"/>
                                        </svg>
                                        Use My Current Location
                                    </button>
                                </div>
                                <div id="locationError" class="alert alert-danger" style="display: none;"></div>
                                <div id="locationInfo" class="alert alert-info" style="display: none;">
                                    <strong id="selectedLocationName">Selected Location</strong><br>
                                    <small class="text-muted">
                                        Lat: <span id="selectedLat">-</span>, Lon: <span id="selectedLon">-</span>
                                    </small>
                                </div>
                                <div class="mt-3">
                                    <p class="small text-muted mb-2"><strong>Popular Sailing Destinations:</strong></p>
                                    <div class="d-flex flex-wrap gap-1">
                                        <button class="btn btn-sm btn-outline-primary" onclick="quickLocation('Sydney', -33.8688, 151.2093)">Sydney</button>
                                        <button class="btn btn-sm btn-outline-primary" onclick="quickLocation('Newport', 41.4901, -71.3128)">Newport RI</button>
                                        <button class="btn btn-sm btn-outline-primary" onclick="quickLocation('San Diego', 32.7157, -117.1611)">San Diego</button>
                                        <button class="btn btn-sm btn-outline-primary" onclick="quickLocation('Miami', 25.7617, -80.1918)">Miami</button>
                                        <button class="btn btn-sm btn-outline-primary" onclick="quickLocation('Auckland', -36.8485, 174.7633)">Auckland</button>
                                    </div>
                                </div>
                            </div>
                            <!-- Right side: Map -->
                            <div class="col-md-7">
                                <div id="locationMap" style="height: 400px; border-radius: 8px; border: 2px solid var(--border-color);"></div>
                                <small class="text-muted d-block mt-2">Click on the map to select a location</small>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" id="setLocationBtn" onclick="confirmLocation()" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-circle me-1" viewBox="0 0 16 16">
                                <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                                <path d="M10.97 4.97a.235.235 0 0 0-.02.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-1.071-1.05z"/>
                            </svg>
                            Set Location
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Featured Listings Section -->
        <h2 class="mb-4 mt-5">Featured Listings</h2>
        
        {% if featured_products and featured_products|length > 0 %}
        <!-- Carousel -->
        <style>
            #featuredCarousel .carousel-control-prev {
                left: -60px;
            }
            #featuredCarousel .carousel-control-next {
                right: -60px;
            }
            #featuredCarousel .carousel-control-prev-icon,
            #featuredCarousel .carousel-control-next-icon {
                background-color: rgba(0, 0, 0, 0.5);
                border-radius: 50%;
                width: 40px;
                height: 40px;
                padding: 8px;
            }
            @media (max-width: 768px) {
                #featuredCarousel .carousel-control-prev {
                    left: 0;
                }
                #featuredCarousel .carousel-control-next {
                    right: 0;
                }
                .carousel-item .col-md-4:nth-child(n+2) {
                    display: none;
                }
            }
            @media (min-width: 769px) and (max-width: 991px) {
                .carousel-item .col-md-4:nth-child(3) {
                    display: none;
                }
            }
        </style>
        <div id="featuredCarousel" class="carousel slide mb-5">
            <div class="carousel-indicators">
                {% set products_to_show = featured_products * 3 if featured_products|length < 3 else featured_products %}
                {% for i in range(0, products_to_show|length, 3) %}
                <button type="button" data-bs-target="#featuredCarousel" data-bs-slide-to="{{ loop.index0 }}" {% if loop.first %}class="active" aria-current="true"{% endif %} aria-label="Slide {{ loop.index }}"></button>
                {% endfor %}
            </div>
            <div class="carousel-inner">
                {% set products_to_show = featured_products * 3 if featured_products|length < 3 else featured_products %}
                {% for i in range(0, products_to_show|length, 3) %}
                <div class="carousel-item {% if loop.first %}active{% endif %}">
                    <div class="row g-3">
                        {% for p in products_to_show[i:i+3] %}
                        <div class="col-md-4">
                            <a href="{{ url_for('product_detail', product_id=p['id']) }}" class="text-decoration-none" style="color: inherit;">
                                <div class="listing-card position-relative h-100" style="cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;" onmouseover="this.style.transform='translateY(-5px)'; this.style.boxShadow='0 8px 16px rgba(0,0,0,0.15)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.1)';">
                                    {% if p['stock'] is not none and p['stock'] == 0 %}
                                        <span class="out-of-stock-badge">Out of Stock</span>
                                    {% endif %}
                                    
                                    <!-- Product Image -->
                                    <div class="text-center mb-3" style="background: #f8f9fa; border-radius: 8px; padding: 15px; height: 250px; display: flex; align-items: center; justify-content: center;">
                                        {% if 'image_url' in p.keys() and p['image_url'] %}
                                            {% set img = p['image_url'] %}
                                            {% if img.startswith('http://') or img.startswith('https://') or img.startswith('/') %}
                                                <img src="{{ img }}" alt="{{ p['title'] }}" style="max-height: 100%; max-width: 100%; object-fit: contain;">
                                            {% else %}
                                                <img src="{{ url_for('static', filename='img/' ~ img) }}" alt="{{ p['title'] }}" style="max-height: 100%; max-width: 100%; object-fit: contain;">
                                            {% endif %}
                                        {% else %}
                                            <img src="https://via.placeholder.com/400x250/e9ecef/6c757d?text={{ p['title'][:20] }}" alt="{{ p['title'] }}" style="max-height: 100%; max-width: 100%; object-fit: contain;">
                                        {% endif %}
                                    </div>
                                    
                                    <h5 class="mb-2">{{ p['title'][:50] }}{% if p['title']|length > 50 %}...{% endif %}</h5>
                                    <p class="price mb-2">${{ '%.2f'|format(p['price']) }}</p>
                                    <div class="description-text">
                                        {% if p['description'] %}
                                            <p class="text-muted small mb-2">{{ p['description'][:80] }}{% if p['description']|length > 80 %}...{% endif %}</p>
                                        {% else %}
                                            <p class="text-muted small mb-2">&nbsp;</p>
                                        {% endif %}
                                    </div>
                                    <div class="seller-info mb-2">
                                        <span class="seller-name">{{ p['business_name'] or p['seller_username'] or 'Seller' }}</span>
                                        {% if p['rating'] %}
                                            <span class="rating">★ {{ '%.1f'|format(p['rating']) }}</span>
                                        {% endif %}
                                    </div>
                                </div>
                            </a>
                        </div>
                        {% endfor %}
                    </div>
                </div>
                {% endfor %}
            </div>
            <button class="carousel-control-prev" type="button" data-bs-target="#featuredCarousel" data-bs-slide="prev">
                <span class="carousel-control-prev-icon" aria-hidden="true"></span>
                <span class="visually-hidden">Previous</span>
            </button>
            <button class="carousel-control-next" type="button" data-bs-target="#featuredCarousel" data-bs-slide="next">
                <span class="carousel-control-next-icon" aria-hidden="true"></span>
                <span class="visually-hidden">Next</span>
            </button>
        </div>
        
        <script>
            // Make carousel truly infinite and continuous
            document.addEventListener('DOMContentLoaded', function() {
                const carousel = document.getElementById('featuredCarousel');
                if (carousel) {
                    const carouselInstance = new bootstrap.Carousel(carousel, {
                        interval: 3000,  // Auto-advance every 3 seconds
                        wrap: true,      // Enable looping
                        ride: 'carousel', // Start automatically
                        pause: 'hover'   // Pause on hover
                    });
                    
                    // Ensure smooth continuous scrolling
                    carousel.addEventListener('slid.bs.carousel', function () {
                        // Bootstrap handles the wrapping automatically with wrap: true
                    });
                }
            });
        </script>
        
        {% else %}
        <div class="text-center">
            <p>No featured listings available.</p>
        </div>
        {% endif %}

        <!-- Popular Categories Section -->
        <div class="my-5">
            <h3 class="mb-4 text-center">Browse Sailing Categories</h3>
            <div class="row row-cols-2 row-cols-md-3 row-cols-lg-6 g-3">
                <div class="col">
                    <a href="{{ url_for('products', category='Sailboats') }}" class="text-decoration-none">
                        <div class="card text-center h-100 category-card" style="transition: all 0.3s;">
                            <div class="card-body">
                                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentColor" class="bi bi-laptop mb-2 text-primary" viewBox="0 0 16 16">
                                    <path d="M13.5 3a.5.5 0 0 1 .5.5V11H2V3.5a.5.5 0 0 1 .5-.5h11zm-11-1A1.5 1.5 0 0 0 1 3.5V12h14V3.5A1.5 1.5 0 0 0 13.5 2h-11zM0 12.5h16a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 12.5z"/>
                                </svg>
                                <h6>Sailboats</h6>
                            </div>
                        </div>
                    </a>
                </div>
                <div class="col">
                    <a href="{{ url_for('products', category='Gear') }}" class="text-decoration-none">
                        <div class="card text-center h-100 category-card" style="transition: all 0.3s;">
                            <div class="card-body">
                                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentColor" class="bi bi-house-door mb-2 text-success" viewBox="0 0 16 16">
                                    <path d="M8.354 1.146a.5.5 0 0 0-.708 0l-6 6A.5.5 0 0 0 1.5 7.5v7a.5.5 0 0 0 .5.5h4.5a.5.5 0 0 0 .5-.5v-4h2v4a.5.5 0 0 0 .5.5H14a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.146-.354L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.354 1.146zM2.5 14V7.707l5.5-5.5 5.5 5.5V14H10v-4a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5v4H2.5z"/>
                                </svg>
                                <h6>Gear</h6>
                            </div>
                        </div>
                    </a>
                </div>
                <div class="col">
                    <a href="{{ url_for('products', category='Rigging') }}" class="text-decoration-none">
                        <div class="card text-center h-100 category-card" style="transition: all 0.3s;">
                            <div class="card-body">
                                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentColor" class="bi bi-bag mb-2 text-danger" viewBox="0 0 16 16">
                                    <path d="M8 1a2.5 2.5 0 0 1 2.5 2.5V4h-5v-.5A2.5 2.5 0 0 1 8 1zm3.5 3v-.5a3.5 3.5 0 1 0-7 0V4H1v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V4h-3.5zM2 5h12v9a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V5z"/>
                                </svg>
                                <h6>Rigging</h6>
                            </div>
                        </div>
                    </a>
                </div>
                <div class="col">
                    <a href="{{ url_for('products', category='Sails') }}" class="text-decoration-none">
                        <div class="card text-center h-100 category-card" style="transition: all 0.3s;">
                            <div class="card-body">
                                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentColor" class="bi bi-book mb-2 text-info" viewBox="0 0 16 16">
                                    <path d="M1 2.828c.885-.37 2.154-.769 3.388-.893 1.33-.134 2.458.063 3.112.752v9.746c-.935-.53-2.12-.603-3.213-.493-1.18.12-2.37.461-3.287.811V2.828zm7.5-.141c.654-.689 1.782-.886 3.112-.752 1.234.124 2.503.523 3.388.893v9.923c-.918-.35-2.107-.692-3.287-.81-1.094-.111-2.278-.039-3.213.492V2.687zM8 1.783C7.015.936 5.587.81 4.287.94c-1.514.153-3.042.672-3.994 1.105A.5.5 0 0 0 0 2.5v11a.5.5 0 0 0 .707.455c.882-.4 2.303-.881 3.68-1.02 1.409-.142 2.59.087 3.223.877a.5.5 0 0 0 .78 0c.633-.79 1.814-1.019 3.222-.877 1.378.139 2.8.62 3.681 1.02A.5.5 0 0 0 16 13.5v-11a.5.5 0 0 0-.293-.455c-.952-.433-2.48-.952-3.994-1.105C10.413.809 8.985.936 8 1.783z"/>
                                </svg>
                                <h6>Sails</h6>
                            </div>
                        </div>
                    </a>
                </div>
                <div class="col">
                    <a href="{{ url_for('products', category='Safety') }}" class="text-decoration-none">
                        <div class="card text-center h-100 category-card" style="transition: all 0.3s;">
                            <div class="card-body">
                                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentColor" class="bi bi-trophy mb-2 text-warning" viewBox="0 0 16 16">
                                    <path d="M2.5.5A.5.5 0 0 1 3 0h10a.5.5 0 0 1 .5.5c0 .538-.012 1.05-.034 1.536a3 3 0 1 1-1.133 5.89c-.79 1.865-1.878 2.777-2.833 3.011v2.173l1.425.356c.194.048.377.135.537.255L13.3 15.1a.5.5 0 0 1-.3.9H3a.5.5 0 0 1-.3-.9l1.838-1.379c.16-.12.343-.207.537-.255L6.5 13.11v-2.173c-.955-.234-2.043-1.146-2.833-3.012a3 3 0 1 1-1.132-5.89A33.076 33.076 0 0 1 2.5.5zm.099 2.54a2 2 0 0 0 .72 3.935c-.333-1.05-.588-2.346-.72-3.935zm10.083 3.935a2 2 0 0 0 .72-3.935c-.133 1.59-.388 2.885-.72 3.935zM3.504 1c.007.517.026 1.006.056 1.469.13 2.028.457 3.546.87 4.667C5.294 9.48 6.484 10 7 10a.5.5 0 0 1 .5.5v2.61a1 1 0 0 1-.757.97l-1.426.356a.5.5 0 0 0-.179.085L4.5 15h7l-.638-.479a.501.501 0 0 0-.18-.085l-1.425-.356a1 1 0 0 1-.757-.97V10.5A.5.5 0 0 1 9 10c.516 0 1.706-.52 2.57-2.864.413-1.12.74-2.64.87-4.667.03-.463.049-.952.056-1.469H3.504z"/>
                                </svg>
                                <h6>Safety</h6>
                            </div>
                        </div>
                    </a>
                </div>
                <div class="col">
                    <a href="{{ url_for('products', category='Accessories') }}" class="text-decoration-none">
                        <div class="card text-center h-100 category-card" style="transition: all 0.3s;">
                            <div class="card-body">
                                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentColor" class="bi bi-grid-3x3-gap mb-2 text-secondary" viewBox="0 0 16 16">
                                    <path d="M4 2v2H2V2h2zm1 12v-2a1 1 0 0 0-1-1H2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1zm0-5V7a1 1 0 0 0-1-1H2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1zm5 5v-2a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1zm0-5V7a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1zM9 2v2H7V2h2zm5 0v2h-2V2h2zM4 7v2H2V7h2zm5 0v2H7V7h2zm5 0h-2v2h2V7zM4 12v2H2v-2h2zm5 0v2H7v-2h2zm5 0v2h-2v-2h2zM12 1a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1h-2zm-1 6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1V7zm1 4a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1h-2z"/>
                                </svg>
                                <h6>Accessories</h6>
                            </div>
                        </div>
                    </a>
                </div>
            </div>
        </div>
    </div>

    <!-- Stats Section -->
    <div class="container">
        <div class="stats-section">
            <div class="row">
                <div class="col-md-4">
                    <div class="stat-item">
                        <div class="stat-number">{{ stats['active_listings'] if stats else '0' }}</div>
                        <div class="stat-label">Active Listings</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="stat-item">
                        <div class="stat-number">{{ stats['total_sellers'] if stats else '0' }}</div>
                        <div class="stat-label">Trusted Sellers</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="stat-item">
                        <div class="stat-number">{{ stats['total_users'] if stats else '0' }}+</div>
                        <div class="stat-label">Community Members</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- How It Works Section -->
    <div class="container my-5">
        <div class="py-5" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 15px;">
            <h3 class="mb-4 text-center text-white">How It Works</h3>
            <div class="row g-4 px-3">
                <div class="col-md-4">
                    <div class="text-center text-white">
                        <div class="mb-3">
                            <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="currentColor" class="bi bi-search" viewBox="0 0 16 16">
                                <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
                            </svg>
                        </div>
                        <h5>1. Browse Listings</h5>
                        <p>Search through thousands of local listings or browse by category</p>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="text-center text-white">
                        <div class="mb-3">
                            <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="currentColor" class="bi bi-chat-dots" viewBox="0 0 16 16">
                                <path d="M5 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm4 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 1a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"/>
                                <path d="m2.165 15.803.02-.004c1.83-.363 2.948-.842 3.468-1.105A9.06 9.06 0 0 0 8 15c4.418 0 8-3.134 8-7s-3.582-7-8-7-8 3.134-8 7c0 1.76.743 3.37 1.97 4.6a10.437 10.437 0 0 1-.524 2.318l-.003.011a10.722 10.722 0 0 1-.244.637c-.079.186.074.394.273.362a21.673 21.673 0 0 0 .693-.125zm.8-3.108a1 1 0 0 0-.287-.801C1.618 10.83 1 9.468 1 8c0-3.192 3.004-6 7-6s7 2.808 7 6c0 3.193-3.004 6-7 6a8.06 8.06 0 0 1-2.088-.272 1 1 0 0 0-.711.074c-.387.196-1.24.57-2.634.893a10.97 10.97 0 0 0 .398-2z"/>
                            </svg>
                        </div>
                        <h5>2. Connect with Sellers</h5>
                        <p>Message sellers, ask questions, and arrange safe meetups</p>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="text-center text-white">
                        <div class="mb-3">
                            <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="currentColor" class="bi bi-bag-check" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M10.854 8.146a.5.5 0 0 1 0 .708l-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708 0z"/>
                                <path d="M8 1a2.5 2.5 0 0 1 2.5 2.5V4h-5v-.5A2.5 2.5 0 0 1 8 1zm3.5 3v-.5a3.5 3.5 0 1 0-7 0V4H1v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V4h-3.5zM2 5h12v9a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V5z"/>
                            </svg>
                        </div>
                        <h5>3. Complete the Deal</h5>
                        <p>Buy or sell items safely in your local community</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Recently Viewed Section -->
    {% if recently_viewed and recently_viewed|length > 0 %}
    <div class="container my-5">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h3>
                <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="currentColor" class="bi bi-clock-history me-2" viewBox="0 0 16 16">
                    <path d="M8.515 1.019A7 7 0 0 0 8 1V0a8 8 0 0 1 .589.022l-.074.997zm2.004.45a7.003 7.003 0 0 0-.985-.299l.219-.976c.383.086.76.2 1.126.342l-.36.933zm1.37.71a7.01 7.01 0 0 0-.439-.27l.493-.87a8.025 8.025 0 0 1 .979.654l-.615.789a6.996 6.996 0 0 0-.418-.302zm1.834 1.79a6.99 6.99 0 0 0-.653-.796l.724-.69c.27.285.52.59.747.91l-.818.576zm.744 1.352a7.08 7.08 0 0 0-.214-.468l.893-.45a7.976 7.976 0 0 1 .45 1.088l-.95.313a7.023 7.023 0 0 0-.179-.483zm.53 2.507a6.991 6.991 0 0 0-.1-1.025l.985-.17c.067.386.106.778.116 1.17l-1 .025zm-.131 1.538c.033-.17.06-.339.081-.51l.993.123a7.957 7.957 0 0 1-.23 1.155l-.964-.267c.046-.165.086-.332.12-.501zm-.952 2.379c.184-.29.346-.594.486-.908l.914.405c-.16.36-.345.706-.555 1.038l-.845-.535zm-.964 1.205c.122-.122.239-.248.35-.378l.758.653a8.073 8.073 0 0 1-.401.432l-.707-.707z"/>
                    <path d="M8 1a7 7 0 1 0 4.95 11.95l.707.707A8.001 8.001 0 1 1 8 0v1z"/>
                    <path d="M7.5 3a.5.5 0 0 1 .5.5v5.21l3.248 1.856a.5.5 0 0 1-.496.868l-3.5-2A.5.5 0 0 1 7 9V3.5a.5.5 0 0 1 .5-.5z"/>
                </svg>
                Recently Viewed
            </h3>
        </div>

        <div class="row row-cols-2 row-cols-md-4 g-3">
            {% for p in recently_viewed %}
                <div class="col">
                    <div class="card h-100 recently-viewed-card" style="transition: transform 0.2s;">
                        <a href="{{ url_for('product_detail', product_id=p['id']) }}" class="text-decoration-none text-dark">
                            {% if 'image_url' in p.keys() and p['image_url'] %}
                                {% set img = p['image_url'] %}
                                {% if img.startswith('http://') or img.startswith('https://') or img.startswith('/') %}
                                    <img src="{{ img }}" class="card-img-top" alt="{{ p['title'] }}" style="height: 180px; object-fit: contain; background: #fff; padding: 10px;">
                                {% else %}
                                    <img src="{{ url_for('static', filename='img/' ~ img) }}" class="card-img-top" alt="{{ p['title'] }}" style="height: 180px; object-fit: contain; background: #fff; padding: 10px;">
                                {% endif %}
                            {% else %}
                                <img src="https://via.placeholder.com/200x180?text=No+Image" class="card-img-top" alt="No image" style="height: 180px; object-fit: contain;">
                            {% endif %}
                            <div class="card-body p-3">
                                <h6 class="card-title mb-2" style="overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical;">{{ p['title'] }}</h6>
                                <p class="card-text text-success fw-bold mb-2">${{ '%.2f'|format(p['price']) }}</p>
                                {% if p['stock'] is not none and p['stock'] <= 0 %}
                                    <span class="badge bg-danger">Out of stock</span>
                                {% elif p['stock'] is not none and p['stock'] < 5 %}
                                    <span class="badge bg-warning text-dark">{{ p['stock'] }} left</span>
                                {% endif %}
                            </div>
                        </a>
                    </div>
                </div>
            {% endfor %}
        </div>
    </div>

    <script>
        // Add hover effect to recently viewed cards
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.recently-viewed-card').forEach(card => {
                card.addEventListener('mouseenter', () => {
                    card.style.transform = 'translateY(-5px)';
                    card.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
                });
                card.addEventListener('mouseleave', () => {
                    card.style.transform = 'translateY(0)';
                    card.style.boxShadow = '';
                });
            });
        });
    </script>
    {% endif %}

    {% include 'footer.html' %}
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Leaflet JS for map -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Ocean Popularity Visualization Script -->
    <script>
        // Serialize popular products for the ocean visualization
        // Load product popularity data from hidden data attribute (avoids raw template braces inside JS)
        const POPULAR_PRODUCTS = (function(){
            const el = document.getElementById('popularProductsData');
            if (!el) return [];
            try { return JSON.parse(el.dataset.products || '[]'); } catch(e){ return []; }
        })();

        (function() {
            const canvas = document.getElementById('oceanCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const tooltip = document.getElementById('oceanTooltip');
            const overlay = document.getElementById('oceanOverlay');
            const container = canvas.parentElement;
            // Offscreen noise canvas for subtle ocean texture
            const noiseCanvas = document.createElement('canvas');
            const noiseCtx = noiseCanvas.getContext('2d');

            // Read CSS variables for theming
            function cssVar(name, fallback) {
                const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
                return v || fallback;
            }
            function hexToRgba(hex, alpha) {
                const h = hex.replace('#','');
                const bigint = parseInt(h, 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            const colors = {
                ocean: cssVar('--ocean-blue', '#006994'),
                wave: cssVar('--wave-color', '#4a90e2'),
                accent: cssVar('--accent-color', '#FF6B35')
            };
            // Category color accents (stripe on deck)
            const categoryColors = {
                'Sailboats': '#2b8be3',
                'Rigging': '#e37b2b',
                'Safety': '#e32b4d',
                'Navigation': '#7b2be3',
                'Accessories': '#2be38c'
            };

            let dpr = window.devicePixelRatio || 1;
            let width = 0, height = 0;
            // Day/Night cycle settings
            const DAY_NIGHT_SECONDS = 120; // full cycle duration
            // Starfield removed; using boat lights at night instead
            function lerp(a, b, t) { return a + (b - a) * t; }
            function hexToRgb(hex) {
                const h = hex.replace('#','');
                const bigint = parseInt(h, 16);
                return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
            }
            function rgbToHex(r, g, b) {
                return '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('');
            }
            function mixHex(c1, c2, t) {
                const a = hexToRgb(c1), b = hexToRgb(c2);
                const r = Math.round(lerp(a.r, b.r, t));
                const g = Math.round(lerp(a.g, b.g, t));
                const bb = Math.round(lerp(a.b, b.b, t));
                return rgbToHex(r, g, bb);
            }

            function buildNoise() {
                // Build a small tiled noise texture for water shimmer
                noiseCanvas.width = 128;
                noiseCanvas.height = 128;
                const id = noiseCtx.createImageData(noiseCanvas.width, noiseCanvas.height);
                for (let i = 0; i < id.data.length; i += 4) {
                    const v = Math.random() * 255;
                    id.data[i] = 0; // R
                    id.data[i+1] = 0; // G
                    id.data[i+2] = 0; // B
                    id.data[i+3] = v < 130 ? 0 : 24; // Sparse alpha speckles
                }
                noiseCtx.putImageData(id, 0, 0);
            }
            buildNoise();

            function resizeCanvas() {
                dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                width = Math.max(300, Math.floor(rect.width));
                height = Math.max(180, Math.floor(rect.height));
                canvas.width = Math.floor(width * dpr);
                canvas.height = Math.floor(height * dpr);
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                // No starfield generation (boat nav lights will indicate night)
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Boats are independent of products
            const boats = [];
            const wakeParticles = [];
            const now = () => performance.now();

            function rand(min, max) { return Math.random() * (max - min) + min; }
            // Randomly choose direction so boats spawn from all four directions

            // No popularity metrics

            const BOAT_SPEED = 18;

            function addBoatForProduct() {
                // Choose random direction: 0=right, 1=down, 2=left, 3=up
                const direction = Math.floor(Math.random() * 4);
                let startX, startY, baseHeading, speedX, speedY;
                
                // Add angle variation (±20 degrees) and variable speed (60%..160% of base)
                const angleVariation = rand(-0.35, 0.35); // ±20 degrees in radians
                const speedVariation = rand(0.6, 1.6);
                const baseSpeed = BOAT_SPEED * speedVariation;
                
                switch(direction) {
                    case 0: // From left, moving right
                        startX = rand(-140, -20);
                        startY = rand(0, height);  // Full height range
                        baseHeading = 0 + angleVariation;
                        speedX = Math.cos(baseHeading) * baseSpeed;
                        speedY = Math.sin(baseHeading) * baseSpeed;
                        break;
                    case 1: // From top, moving down
                        startX = rand(0, width);  // Full width range
                        startY = rand(-140, -20);
                        baseHeading = Math.PI / 2 + angleVariation;
                        speedX = Math.cos(baseHeading) * baseSpeed;
                        speedY = Math.sin(baseHeading) * baseSpeed;
                        break;
                    case 2: // From right, moving left
                        startX = rand(width + 20, width + 160);
                        startY = rand(0, height);  // Full height range
                        baseHeading = Math.PI + angleVariation;
                        speedX = Math.cos(baseHeading) * baseSpeed;
                        speedY = Math.sin(baseHeading) * baseSpeed;
                        break;
                    case 3: // From bottom, moving up
                        startX = rand(0, width);  // Full width range
                        startY = rand(height + 20, height + 160);
                        baseHeading = -Math.PI / 2 + angleVariation;
                        speedX = Math.cos(baseHeading) * baseSpeed;
                        speedY = Math.sin(baseHeading) * baseSpeed;
                        break;
                }
                
                // Uniform smaller size for all boats
                const length = 52;
                let amplitude = rand(0.3, 0.8); // reduced bob amplitude for gentler movement
                let frequency = rand(0.0015, 0.003);
                const phase = rand(0, Math.PI * 2);
                const jitter = rand(-0.08, 0.08); // minor deviation only
                const theta = baseHeading + jitter; // heading primary direction

                // Enforce spawn separation: re-sample position if too close to existing boats
                // This spreads boats out more across the canvas on entry
                (function enforceSpawnSeparation() {
                    const sepMin = Math.max(140, length * 1.1); // minimum separation distance
                    let tries = 0;
                    while (tries < 10) {
                        let tooClose = false;
                        for (let i = 0; i < boats.length; i++) {
                            const bx = boats[i].x;
                            const by = (boats[i].baseY !== undefined ? boats[i].baseY : boats[i].y);
                            const dx = startX - bx;
                            const dy = startY - by;
                            if (Math.hypot(dx, dy) < sepMin) { tooClose = true; break; }
                        }
                        if (!tooClose) break;
                        // Re-sample along the axis perpendicular to movement to spread lanes
                        if (direction === 0 || direction === 2) {
                            startY = rand(0, height);
                        } else {
                            startX = rand(0, width);
                        }
                        tries++;
                    }
                })();
                // Randomized tier (visual embellishments)
                let tier = 1; const rTier = Math.random();
                if (rTier > 0.85) tier = 3; else if (rTier > 0.55) tier = 2;
                
                // Sequential rotation with tier-biased skip ensures all designs appear over time
                if (typeof window.__boatCycleIndex === 'undefined') {
                    window.__boatCycleIndex = 0;
                }
                const ALL_BOAT_TYPES = ['sloop','catamaran','yacht','dinghy','racer','speedboat','ferry','trawler','barge','kayak'];
                const tierBiasMap = { 1: 0.15, 2: 0.35, 3: 0.55 };
                const bias = tierBiasMap[tier] || 0.15;
                window.__boatCycleIndex = (window.__boatCycleIndex + 1 + (Math.random() < bias ? 1 : 0)) % ALL_BOAT_TYPES.length;
                const boatType = ALL_BOAT_TYPES[window.__boatCycleIndex];

                // Per-boat-type motion & size profiles (speed multiplier, bob amplitude, frequency override)
                const BOAT_PROFILES = {
                    sloop:      { speed: 1.00, amp: 14, freq: 0.12 },
                    catamaran:  { speed: 1.05, amp: 13, freq: 0.11 },
                    yacht:      { speed: 0.95, amp: 12, freq: 0.10 },
                    dinghy:     { speed: 0.85, amp: 11, freq: 0.14 },
                    racer:      { speed: 1.18, amp: 15, freq: 0.15 },
                    speedboat:  { speed: 1.32, amp: 9,  freq: 0.16 },
                    ferry:      { speed: 0.78, amp: 8,  freq: 0.09 },
                    trawler:    { speed: 0.75, amp: 7,  freq: 0.085 },
                    barge:      { speed: 0.60, amp: 5,  freq: 0.07 },
                    kayak:      { speed: 0.92, amp: 12, freq: 0.18 }
                };
                const profile = BOAT_PROFILES[boatType] || { speed: 1, amp: 12, freq: 0.12 };
                // Apply speed multiplier
                speedX *= profile.speed;
                speedY *= profile.speed;
                // Override bob amplitude & frequency (convert freq from cycles/sec to internal usage ~ milliseconds factor)
                const amplitudeScaled = profile.amp * 0.7; // scale down to canvas units
                frequency = profile.freq / 1000; // override base frequency (stored as per-ms factor)
                
                // Per-boat color and wake factor
                const palette = ['#1e90ff', '#ff7043', '#66bb6a', '#ab47bc', '#ffa726', '#29b6f6', '#ef5350', '#26a69a'];
                const color = palette[Math.floor(Math.random() * palette.length)];
                const wakeFactor = rand(0.8, 1.4);
                const speedRef = BOAT_SPEED * 1.6;

                boats.push({
                    tier,
                    boatType,
                    headingJitter: jitter,
                    x: startX,
                    y: startY,
                    baseY: startY,
                    baseX: startX,
                    speedX,
                    speedY,
                    direction,
                    len: length,
                    amp: amplitudeScaled,
                    freq: frequency,
                    phase,
                    theta,
                    hover: false,
                    color,
                    wakeFactor,
                    speedRef
                });
            }

            // Hard cap total boats (independent of products)
            const MAX_BOATS = 4;
            for (let i = 0; i < MAX_BOATS; i++) addBoatForProduct();

            // No product images used

            function drawBackground(t) {
                // Day-night cycle progression 0..1
                const p = (t % DAY_NIGHT_SECONDS) / DAY_NIGHT_SECONDS;
                const dayLight = 0.5 - 0.5 * Math.cos(2 * Math.PI * p); // 0 at midnight, 1 at noon
                const nightBlend = 1 - dayLight;

                // Water gradient blended between day and night palettes
                const dayTop = '#5fb8ff', dayMid = '#1f8bd4', dayBot = '#0e629b';
                const nightTop = '#00152a', nightMid = '#00223d', nightBot = '#00294d';
                const topCol = mixHex(nightTop, dayTop, dayLight);
                const midCol = mixHex(nightMid, dayMid, dayLight);
                const botCol = mixHex(nightBot, dayBot, dayLight);
                const grad = ctx.createLinearGradient(0, 0, 0, height);
                grad.addColorStop(0, hexToRgba(topCol, 0.95));
                grad.addColorStop(0.55, hexToRgba(midCol, 0.98));
                grad.addColorStop(1, hexToRgba(botCol, 1.0));
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, width, height);

                // Starfield removed — night ambiance driven by glow and boat lights

                // Dynamic wave bands with slight perspective skew; alpha scales with daylight
                const layers = [
                    { amp: 12, wl: 210, spd: 0.25, alpha: 0.16 + 0.10 * dayLight, shade: colors.wave },
                    { amp: 8,  wl: 140, spd: 0.45, alpha: 0.12 + 0.08 * dayLight, shade: colors.wave },
                    { amp: 5,  wl: 90,  spd: 0.75, alpha: 0.10 + 0.06 * dayLight, shade: colors.wave }
                ];
                layers.forEach((L, idx) => {
                    ctx.beginPath();
                    for (let x = 0; x <= width; x += 3) {
                        const y = height * 0.58 + Math.sin((x / L.wl) + t * L.spd) * L.amp + idx * 6;
                        // Parallax skew: shift based on layer index
                        const sx = x + Math.sin(t * 0.15 + idx) * idx * 2;
                        if (x === 0) ctx.moveTo(sx, y); else ctx.lineTo(sx, y);
                    }
                    ctx.lineTo(width, height);
                    ctx.lineTo(0, height);
                    ctx.closePath();
                    ctx.fillStyle = hexToRgba(L.shade, L.alpha);
                    ctx.fill();
                });

                // Sun/Moon glow
                ctx.save();
                if (dayLight > 0.1) {
                    const gx = width * 0.18, gy = height * (0.12 + 0.08 * Math.cos(2 * Math.PI * p));
                    const rg = ctx.createRadialGradient(gx, gy, 0, gx, gy, height * 0.45);
                    rg.addColorStop(0, hexToRgba('#fff8c6', 0.22 * dayLight));
                    rg.addColorStop(1, hexToRgba('#fff8c6', 0));
                    ctx.fillStyle = rg; ctx.fillRect(0, 0, width, height);
                } else {
                    const gx = width * 0.82, gy = height * (0.18 + 0.10 * Math.cos(2 * Math.PI * p));
                    const rg = ctx.createRadialGradient(gx, gy, 0, gx, gy, height * 0.35);
                    rg.addColorStop(0, hexToRgba('#cfe4ff', 0.16 * (nightBlend)));
                    rg.addColorStop(1, hexToRgba('#cfe4ff', 0));
                    ctx.fillStyle = rg; ctx.fillRect(0, 0, width, height);
                }
                ctx.restore();

                // Shimmer texture (scrolling noise)
                ctx.globalAlpha = 0.08 + 0.07 * dayLight;
                const scrollX = (t * 12) % noiseCanvas.width;
                const scrollY = (t * 6) % noiseCanvas.height;
                for (let y = -noiseCanvas.height; y < height + noiseCanvas.height; y += noiseCanvas.height) {
                    for (let x = -noiseCanvas.width; x < width + noiseCanvas.width; x += noiseCanvas.width) {
                        ctx.drawImage(noiseCanvas, Math.floor(x + scrollX), Math.floor(y + scrollY));
                    }
                }
                ctx.globalAlpha = 1;

                // Soft horizon glow
                const glowGrad = ctx.createLinearGradient(0, height * 0.45, 0, height);
                glowGrad.addColorStop(0, hexToRgba('#ffffff', 0.05));
                glowGrad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = glowGrad;
                ctx.fillRect(0, 0, width, height);
            }

            function drawBoat(b, t) {
                // Position & wave motion
                const x = b.x;
                const y = b.baseY + Math.sin(t * 1000 * b.freq + b.phase) * b.amp;
                const len = b.len;
                const beam = Math.max(10, len * 0.34);
                const halfL = len * 0.5;

                // Motion & attitude
                const pitch = Math.sin(t * 0.7 + b.phase) * 0.015;
                const roll = Math.sin(t * 1.1 + b.phase * 0.5) * 0.02;
                const heading = (b.theta || 0) + Math.sin(t * 0.4 + b.phase) * 0.012 + pitch;
                b.heading = heading;
                b.drawY = y;

                // Lighting + day/night darkening
                const facing = Math.max(0.2, 0.8 - Math.abs(roll) * 18);
                const cycleP = (t % DAY_NIGHT_SECONDS) / DAY_NIGHT_SECONDS;
                const dayLight = 0.5 - 0.5 * Math.cos(2 * Math.PI * cycleP);
                const nightBlend = 1 - dayLight; // 0 by day, 1 by night
                const monoBlend = Math.min(1, Math.max(0, (nightBlend - 0.35) / 0.65));
                const monoHex = '#20262e';
                const baseHullHex = b.hover ? colors.accent : (b.color || '#8a98a1');
                const tintedHullHex = mixHex(baseHullHex, '#2a2f38', Math.min(0.7, nightBlend * 0.85));
                const hullTone = mixHex(tintedHullHex, monoHex, monoBlend);
                const hullLight = hexToRgba(hullTone, (0.92 * facing) * (0.95 - 0.25 * nightBlend));
                const hullMid = hexToRgba(hullTone, (0.78 * facing + 0.12) * (0.95 - 0.2 * nightBlend));
                const hullShadow = hexToRgba(mixHex('#8a98a1', monoHex, monoBlend), (0.65 - facing * 0.25) * (0.9 + 0.15 * nightBlend));
                const rawStripe = b.color || '#1e90ff';
                const stripeColor = mixHex(rawStripe, monoHex, monoBlend);
                const strokeColor = b.hover ? hexToRgba('#000000', 0.5) : hexToRgba('#000000', 0.28);

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(heading);
                ctx.transform(1, 0, roll * 0.15, 1, 0, 0); // skew for roll illusion

                // Gradient in local space (rotates with hull)
                const deckGrad = ctx.createLinearGradient(-halfL, -beam * 0.5, halfL, beam * 0.5);
                deckGrad.addColorStop(0, hullShadow);
                deckGrad.addColorStop(0.25, hullMid);
                deckGrad.addColorStop(0.5, hullLight);
                deckGrad.addColorStop(0.75, hullMid);
                deckGrad.addColorStop(1, hullShadow);

                // Soft water shadow
                ctx.save();
                ctx.globalAlpha = 0.12;
                ctx.beginPath();
                ctx.ellipse(-halfL * 0.1, beam * 0.1, halfL * 0.6, beam * 0.45, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#000000';
                ctx.fill();
                ctx.restore();

                // Reflection & under-shadow helpers
                function drawReflection(pathBuilder) {
                    ctx.save();
                    // Tier-based reflection strength (tier1 faint, tier3 stronger)
                    const tierFactor = (0.55 + 0.25 * (b.tier - 1));
                    ctx.globalAlpha = 0.12 * tierFactor * (1 - Math.min(1, Math.abs(roll) * 18));
                    ctx.scale(1, 0.55);
                    ctx.translate(0, beam * 1.05);
                    pathBuilder();
                    const refGrad = ctx.createLinearGradient(0, 0, 0, beam * 1.4);
                    const refColor = mixHex('#ffffff', monoHex, monoBlend * 0.6);
                    refGrad.addColorStop(0, hexToRgba(refColor, 0.35 * dayLight));
                    refGrad.addColorStop(1, hexToRgba(refColor, 0));
                    ctx.fillStyle = refGrad;
                    ctx.fill();
                    ctx.restore();
                }
                function drawUnderShadow(pathBuilder) {
                    ctx.save();
                    ctx.translate(0, beam * 0.18);
                    ctx.globalAlpha = 0.22;
                    pathBuilder();
                    ctx.fillStyle = hexToRgba('#102028', 0.55);
                    ctx.fill();
                    ctx.restore();
                }

                // Boat type rendering
                if (b.boatType === 'catamaran') {
                    const hullOffset = beam * 0.55;
                    const hullWidth = beam * 0.35;
                    const r = hullWidth * 0.5;
                    function hullLeft() {
                        ctx.beginPath();
                        ctx.moveTo(-halfL + r, -hullOffset - r);
                        ctx.lineTo(halfL - r, -hullOffset - r);
                        ctx.arc(halfL - r, -hullOffset, r, -Math.PI/2, Math.PI/2);
                        ctx.lineTo(-halfL + r, -hullOffset + r);
                        ctx.arc(-halfL + r, -hullOffset, r, Math.PI/2, -Math.PI/2);
                        ctx.closePath();
                    }
                    function hullRight() {
                        ctx.beginPath();
                        ctx.moveTo(-halfL + r, hullOffset - r);
                        ctx.lineTo(halfL - r, hullOffset - r);
                        ctx.arc(halfL - r, hullOffset, r, -Math.PI/2, Math.PI/2);
                        ctx.lineTo(-halfL + r, hullOffset + r);
                        ctx.arc(-halfL + r, hullOffset, r, Math.PI/2, -Math.PI/2);
                        ctx.closePath();
                    }
                    hullLeft(); ctx.fillStyle = deckGrad; ctx.fill(); ctx.strokeStyle = strokeColor; ctx.lineWidth = b.hover ? 2 : 1; ctx.stroke();
                    drawUnderShadow(hullLeft); drawReflection(hullLeft);
                    hullRight(); ctx.fillStyle = deckGrad; ctx.fill(); ctx.stroke();
                    drawUnderShadow(hullRight); drawReflection(hullRight);
                    ctx.fillStyle = hexToRgba(stripeColor, b.hover ? 0.7 : 0.5);
                    ctx.fillRect(-halfL * 0.5, -hullOffset + r, halfL, hullOffset * 2 - r * 2);
                    const beamColor = mixHex('#e0e0e0', monoHex, monoBlend * 0.8);
                    ctx.strokeStyle = hexToRgba(beamColor, 0.25 * dayLight); ctx.lineWidth = 0.8;
                    for (let nx = -halfL * 0.45; nx < halfL * 0.5; nx += hullWidth * 0.65) {
                        ctx.beginPath(); ctx.moveTo(nx, -hullOffset + r); ctx.lineTo(nx + hullWidth * 0.4, hullOffset - r); ctx.stroke();
                    }
                } else if (b.boatType === 'speedboat') {
                    // Speedboat: low sleek hull with windshield
                    const r = beam * 0.45;
                    function hull() {
                        ctx.beginPath();
                        ctx.moveTo(-halfL + r * 0.9, -r * 0.6);
                        ctx.quadraticCurveTo(0, -r * 1.1, halfL * 0.8, -r * 0.6);
                        ctx.lineTo(halfL, 0);
                        ctx.lineTo(halfL * 0.8, r * 0.6);
                        ctx.quadraticCurveTo(0, r * 1.05, -halfL + r * 0.9, r * 0.6);
                        ctx.arc(-halfL + r * 0.9, 0, r * 0.6, Math.PI/2, -Math.PI/2, true);
                        ctx.closePath();
                    }
                    hull(); ctx.fillStyle = deckGrad; ctx.fill(); ctx.strokeStyle = strokeColor; ctx.lineWidth = b.hover ? 2 : 1; ctx.stroke();
                    drawUnderShadow(hull); drawReflection(hull);
                    // Windshield
                    ctx.beginPath();
                    ctx.moveTo(-halfL * 0.05, -r * 0.4);
                    ctx.lineTo(halfL * 0.25, -r * 0.25);
                    ctx.lineTo(halfL * 0.22, 0);
                    ctx.lineTo(-halfL * 0.05, 0);
                    ctx.closePath();
                    const glassGrad = ctx.createLinearGradient(-halfL * 0.05, -r * 0.4, halfL * 0.25, 0);
                    glassGrad.addColorStop(0, hexToRgba('#5ac8fa', 0.55));
                    glassGrad.addColorStop(1, hexToRgba('#ffffff', 0.15));
                    ctx.fillStyle = glassGrad; ctx.fill();
                } else if (b.boatType === 'ferry') {
                    // Ferry: tall multi-deck rectangular profile
                    const r = beam * 0.55;
                    function hull() {
                        ctx.beginPath();
                        ctx.moveTo(-halfL + r, -r * 0.9);
                        ctx.lineTo(halfL - r, -r * 0.9);
                        ctx.arc(halfL - r, 0, r, -Math.PI/2, Math.PI/2);
                        ctx.lineTo(-halfL + r, r * 0.9);
                        ctx.arc(-halfL + r, 0, r, Math.PI/2, -Math.PI/2);
                        ctx.closePath();
                    }
                    hull(); ctx.fillStyle = deckGrad; ctx.fill(); ctx.strokeStyle = strokeColor; ctx.lineWidth = b.hover ? 2.2 : 1.2; ctx.stroke();
                    drawUnderShadow(hull); drawReflection(hull);
                    // Deck levels
                    const deckCount = 3;
                    for (let d = 0; d < deckCount; d++) {
                        const dy = -beam * 0.6 + d * beam * 0.35;
                        const deckPanelColor = mixHex('#f8f8f8', monoHex, monoBlend * 0.7);
                        ctx.fillStyle = hexToRgba(deckPanelColor, 0.85);
                        ctx.fillRect(-halfL * 0.55, dy, halfL * 1.1, beam * 0.22);
                        // Windows
                        for (let w = 0; w < 6; w++) {
                            const wx = -halfL * 0.5 + w * (halfL * 0.18);
                            ctx.fillStyle = hexToRgba('#5ac8fa', 0.5);
                            ctx.fillRect(wx, dy + beam * 0.03, halfL * 0.12, beam * 0.12);
                        }
                    }
                } else if (b.boatType === 'trawler') {
                    // Trawler: displacement hull with wheelhouse and mast
                    const r = beam * 0.5;
                    function hull() {
                        ctx.beginPath();
                        ctx.moveTo(-halfL + r, -r * 0.8);
                        ctx.quadraticCurveTo(0, -r * 1.3, halfL - r, -r * 0.8);
                        ctx.arc(halfL - r, 0, r, -Math.PI/2, Math.PI/2);
                        ctx.quadraticCurveTo(0, r * 1.3, -halfL + r, r * 0.8);
                        ctx.arc(-halfL + r, 0, r, Math.PI/2, -Math.PI/2);
                        ctx.closePath();
                    }
                    hull(); ctx.fillStyle = deckGrad; ctx.fill(); ctx.strokeStyle = strokeColor; ctx.lineWidth = b.hover ? 2.2 : 1.2; ctx.stroke();
                    drawUnderShadow(hull); drawReflection(hull);
                    // Wheelhouse
                    const wheelhouseColor = mixHex('#ffffff', monoHex, monoBlend * 0.6);
                    ctx.fillStyle = hexToRgba(wheelhouseColor, 0.9);
                    ctx.beginPath(); ctx.roundRect(-halfL * 0.2, -beam * 0.65, halfL * 0.5, beam * 0.5, beam * 0.12); ctx.fill();
                    // Windows
                    for (let i = 0; i < 3; i++) {
                        const wx = -halfL * 0.15 + i * (halfL * 0.15);
                        ctx.fillStyle = hexToRgba('#5ac8fa', 0.6);
                        ctx.fillRect(wx, -beam * 0.55, halfL * 0.1, beam * 0.18);
                    }
                    // Mast
                    ctx.strokeStyle = hexToRgba('#8B4513', 0.85); ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(halfL * 0.05, -beam * 0.6); ctx.lineTo(halfL * 0.05, -len * 0.55); ctx.stroke();
                    // Radar / rig
                    ctx.beginPath(); ctx.arc(halfL * 0.05, -len * 0.55, beam * 0.15, 0, Math.PI * 2); ctx.fillStyle = hexToRgba(stripeColor, 0.6); ctx.fill();
                } else if (b.boatType === 'barge') {
                    // Barge: flat hull carrying containers
                    const r = beam * 0.45;
                    function hull() {
                        ctx.beginPath();
                        ctx.moveTo(-halfL, -r * 0.6);
                        ctx.lineTo(halfL, -r * 0.6);
                        ctx.lineTo(halfL, r * 0.6);
                        ctx.lineTo(-halfL, r * 0.6);
                        ctx.closePath();
                    }
                    hull(); ctx.fillStyle = deckGrad; ctx.fill(); ctx.strokeStyle = strokeColor; ctx.lineWidth = b.hover ? 2.2 : 1.2; ctx.stroke();
                    drawUnderShadow(hull); drawReflection(hull);
                    // Cargo stacks
                    const stackCount = 4;
                    for (let s = 0; s < stackCount; s++) {
                        const sx = -halfL * 0.85 + s * (halfL * 0.55);
                        const sh = beam * (0.25 + (s % 2) * 0.15);
                        ctx.fillStyle = hexToRgba(b.color || '#ffaa00', 0.75);
                        ctx.fillRect(sx, -sh * 0.5, halfL * 0.3, sh);
                    }
                } else if (b.boatType === 'kayak') {
                    // Kayak: very narrow lens shape with paddles
                    const r = beam * 0.35;
                    function hull() {
                        ctx.beginPath();
                        ctx.moveTo(-halfL, 0);
                        ctx.quadraticCurveTo(-halfL * 0.3, -r * 1.4, 0, -r * 1.2);
                        ctx.quadraticCurveTo(halfL * 0.3, -r * 1.4, halfL, 0);
                        ctx.quadraticCurveTo(halfL * 0.3, r * 1.4, 0, r * 1.2);
                        ctx.quadraticCurveTo(-halfL * 0.3, r * 1.4, -halfL, 0);
                        ctx.closePath();
                    }
                    hull(); ctx.fillStyle = deckGrad; ctx.fill(); ctx.strokeStyle = strokeColor; ctx.lineWidth = b.hover ? 2 : 1; ctx.stroke();
                    drawReflection(hull);
                    // Seat opening
                    ctx.beginPath(); ctx.ellipse(0, 0, halfL * 0.25, r * 0.9, 0, 0, Math.PI * 2); ctx.fillStyle = hexToRgba('#000000', 0.25); ctx.fill();
                    // Paddles
                    ctx.strokeStyle = hexToRgba('#c18a3b', b.hover ? 0.9 : 0.6); ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.moveTo(-halfL * 0.1, 0); ctx.lineTo(-halfL * 0.4, -r * 2.2); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(-halfL * 0.1, 0); ctx.lineTo(-halfL * 0.4, r * 2.2); ctx.stroke();
                } else if (b.boatType === 'yacht') {
                    const r = beam * 0.5;
                    function hull() {
                        ctx.beginPath();
                        ctx.moveTo(-halfL + r, -r);
                        ctx.quadraticCurveTo(0, -r * 1.15, halfL - r, -r);
                        ctx.arc(halfL - r, 0, r, -Math.PI/2, Math.PI/2);
                        ctx.quadraticCurveTo(0, r * 1.15, -halfL + r, r);
                        ctx.arc(-halfL + r, 0, r, Math.PI/2, -Math.PI/2);
                        ctx.closePath();
                    }
                    hull(); ctx.fillStyle = deckGrad; ctx.fill(); ctx.strokeStyle = strokeColor; ctx.lineWidth = b.hover ? 2 : 1; ctx.stroke();
                    drawUnderShadow(hull); drawReflection(hull);
                    const cabinLen = halfL * 0.8; const cabinHeight = beam * 0.4;
                    const cabinColor = mixHex('#f0f0f0', monoHex, monoBlend * 0.6);
                    ctx.fillStyle = hexToRgba(cabinColor, 0.9);
                    ctx.beginPath(); ctx.roundRect(-cabinLen * 0.5, -cabinHeight * 0.5, cabinLen, cabinHeight, cabinHeight * 0.3); ctx.fill();
                    ctx.strokeStyle = hexToRgba('#000000', 0.3); ctx.lineWidth = 1; ctx.stroke();
                    for (let i = 0; i < 4; i++) {
                        const wx = -cabinLen * 0.35 + (i / 3) * (cabinLen * 0.7);
                        ctx.fillStyle = hexToRgba('#5ac8fa', 0.6); ctx.fillRect(wx - 3, -cabinHeight * 0.15, 6, cabinHeight * 0.25);
                        const highlightColor = mixHex('#dddddd', monoHex, monoBlend * 0.7);
                        ctx.fillStyle = hexToRgba(highlightColor, 0.25 * dayLight); ctx.fillRect(wx - 3, -cabinHeight * 0.15, 6, cabinHeight * 0.08);
                    }
                } else if (b.boatType === 'dinghy') {
                    const r = beam * 0.5;
                    function hull() {
                        ctx.beginPath();
                        ctx.moveTo(-halfL + r, -r);
                        ctx.quadraticCurveTo(0, -r * 1.25, halfL - r * 1.2, -r * 0.7);
                        ctx.arc(halfL - r * 0.8, 0, r * 0.8, -Math.PI/2, Math.PI/2);
                        ctx.quadraticCurveTo(0, r * 1.15, -halfL + r, r);
                        ctx.arc(-halfL + r, 0, r, Math.PI/2, -Math.PI/2);
                        ctx.closePath();
                    }
                    hull(); ctx.fillStyle = deckGrad; ctx.fill(); ctx.strokeStyle = strokeColor; ctx.lineWidth = b.hover ? 2.5 : 1.5; ctx.stroke();
                    drawReflection(hull);
                    ctx.strokeStyle = hexToRgba('#000000', 0.4); ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(-halfL * 0.3, -r); ctx.lineTo(-halfL * 0.3, r); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(halfL * 0.2, -r * 0.7); ctx.lineTo(halfL * 0.2, r * 0.7); ctx.stroke();
                    ctx.strokeStyle = hexToRgba('#c18a3b', b.hover ? 0.9 : 0.6); ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.moveTo(-halfL * 0.05, -r * 0.2); ctx.lineTo(-halfL * 0.35, -r * 0.9); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(-halfL * 0.05, r * 0.2); ctx.lineTo(-halfL * 0.35, r * 0.9); ctx.stroke();
                } else if (b.boatType === 'racer') {
                    const r = beam * 0.4;
                    function hull() {
                        ctx.beginPath();
                        ctx.moveTo(halfL, 0);
                        ctx.quadraticCurveTo(halfL * 0.75, -r * 1.4, halfL * 0.5, -r);
                        ctx.lineTo(-halfL + r, -r);
                        ctx.arc(-halfL + r, 0, r, -Math.PI/2, Math.PI/2);
                        ctx.lineTo(halfL * 0.5, r);
                        ctx.quadraticCurveTo(halfL * 0.75, r * 1.4, halfL, 0);
                        ctx.closePath();
                    }
                    hull(); ctx.fillStyle = deckGrad; ctx.fill(); ctx.strokeStyle = strokeColor; ctx.lineWidth = b.hover ? 2 : 1; ctx.stroke();
                    drawUnderShadow(hull); drawReflection(hull);
                    ctx.fillStyle = hexToRgba(stripeColor, b.hover ? 1.0 : 0.8);
                    ctx.beginPath(); ctx.moveTo(halfL * 0.9, 0); ctx.lineTo(halfL * 0.6, -r * 0.5); ctx.lineTo(-halfL * 0.6, -r * 0.3); ctx.lineTo(-halfL * 0.6, r * 0.3); ctx.lineTo(halfL * 0.6, r * 0.5); ctx.closePath(); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(-halfL * 0.1, r * 0.05); ctx.lineTo(-halfL * 0.1, r * 0.45); ctx.lineTo(halfL * 0.05, r * 0.05); ctx.closePath(); ctx.fillStyle = hexToRgba('#333', 0.6); ctx.fill();
                } else { // sloop
                    const r = beam * 0.5;
                    function hull() {
                        ctx.beginPath();
                        ctx.moveTo(-halfL + r, -r);
                        ctx.quadraticCurveTo(0, -r * 1.2, halfL - r, -r);
                        ctx.arc(halfL - r, 0, r, -Math.PI/2, Math.PI/2);
                        ctx.quadraticCurveTo(0, r * 1.2, -halfL + r, r);
                        ctx.arc(-halfL + r, 0, r, Math.PI/2, -Math.PI/2);
                        ctx.closePath();
                    }
                    hull(); ctx.fillStyle = deckGrad; ctx.fill(); ctx.strokeStyle = strokeColor; ctx.lineWidth = b.hover ? 2 : 1; ctx.stroke();
                    drawUnderShadow(hull); drawReflection(hull);
                    // Mast & billowed sail
                    ctx.strokeStyle = hexToRgba('#8B4513', 0.8); ctx.lineWidth = 2.5; ctx.beginPath(); ctx.moveTo(0, -r); ctx.lineTo(0, -len * 0.8); ctx.stroke();
                    const billow = Math.sin(t * 1.2 + b.phase) * r * 0.35;
                    ctx.fillStyle = hexToRgba(stripeColor, b.hover ? 0.75 : 0.55);
                    ctx.beginPath(); ctx.moveTo(0, -len * 0.75); ctx.quadraticCurveTo(halfL * 0.45 + billow, -len * 0.4, halfL * 0.6, -r); ctx.lineTo(0, -r); ctx.closePath(); ctx.fill();
                    ctx.strokeStyle = hexToRgba('#000000', 0.25); ctx.lineWidth = 1; ctx.stroke();
                }

                // Category stripe
                ctx.beginPath(); ctx.roundRect(-halfL * 0.6, -beam * 0.15, halfL * 1.2, beam * 0.3, beam * 0.12);
                ctx.fillStyle = hexToRgba(stripeColor, b.hover ? 0.9 : 0.55); ctx.fill();

                // Tier decorations
                if (b.tier >= 2) {
                    ctx.beginPath(); ctx.moveTo(halfL * 0.4, -beam * 0.05); ctx.lineTo(halfL * 0.55, -beam * 0.25); ctx.lineTo(halfL * 0.55, beam * 0.0); ctx.closePath();
                    ctx.fillStyle = hexToRgba(stripeColor, b.hover ? 0.85 : 0.6); ctx.fill();
                }
                if (b.tier >= 3) {
                    const holeCount = Math.max(3, Math.floor(len / 30));
                    for (let i = 0; i < holeCount; i++) {
                        const fx = -halfL * 0.4 + (i / (holeCount - 1)) * (halfL * 0.8);
                        ctx.beginPath(); ctx.arc(fx, beam * 0.28, beam * 0.11, 0, Math.PI * 2); ctx.fillStyle = hexToRgba('#000000', b.hover ? 0.55 : 0.35); ctx.fill();
                        const portholeColor = mixHex('#e8e8e8', monoHex, monoBlend * 0.6);
                        ctx.beginPath(); ctx.arc(fx, beam * 0.28, beam * 0.06, 0, Math.PI * 2); ctx.fillStyle = hexToRgba(portholeColor, (b.hover ? 0.75 : 0.55) * (0.5 + 0.5 * dayLight)); ctx.fill();
                    }
                }

                // Navigation lights at night (port red, starboard green, stern white)
                if (typeof DAY_NIGHT_SECONDS === 'number') {
                    const cycleP2 = (t % DAY_NIGHT_SECONDS) / DAY_NIGHT_SECONDS;
                    const dayLight2 = 0.5 - 0.5 * Math.cos(2 * Math.PI * cycleP2);
                    const nightBlend2 = 1 - dayLight2;
                    if (nightBlend2 > 0.25) {
                        const intensity = Math.min(1, (nightBlend2 - 0.25) * 1.4);
                        const glow = (cx, cy, colorHex, rMul=1, sizeMul=1) => {
                            const rg = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(18, beam * 2.2 * rMul));
                            rg.addColorStop(0, hexToRgba(colorHex, 1.0 * intensity));
                            rg.addColorStop(0.25, hexToRgba(colorHex, 0.85 * intensity));
                            rg.addColorStop(1, hexToRgba(colorHex, 0));
                            ctx.fillStyle = rg;
                            ctx.beginPath(); ctx.arc(cx, cy, Math.max(4, beam * 0.25 * sizeMul), 0, Math.PI * 2); ctx.fill();
                        };
                        // Bow side lights (smaller)
                        glow(halfL * 0.65, -beam * 0.45, '#ff3b30', 0.6, 0.5); // port red (left is -y in local space)
                        glow(halfL * 0.65,  beam * 0.45, '#34c759', 0.6, 0.5); // starboard green
                        // Stern white light
                        glow(-halfL * 0.7, 0, '#ffffff', 0.8);
                        
                        // Rigging lights for sailboats (mast string lights - yellow)
                        if (['sloop', 'catamaran', 'yacht', 'racer'].includes(b.boatType)) {
                            const mastHeight = len * 0.8;
                            const riggingCount = Math.max(3, Math.floor(len / 18));
                            for (let i = 0; i < riggingCount; i++) {
                                const frac = i / (riggingCount - 1);
                                const ry = -beam * 0.5 - mastHeight * frac;
                                const flicker = Math.sin(t * 4.5 + b.phase + i * 0.6) * 0.08 + 0.92;
                                ctx.save();
                                ctx.globalAlpha = intensity * 0.95 * flicker;
                                ctx.fillStyle = '#ffdd00';
                                ctx.beginPath();
                                ctx.arc(0, ry, Math.max(2.5, beam * 0.15), 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }
                        }
                    }
                }

                // Bow marker
                const bowColor = mixHex('#e0e0e0', monoHex, monoBlend * 0.7);
                ctx.beginPath(); ctx.moveTo(halfL - 1, 0); ctx.lineTo(halfL * 0.75, -beam * 0.25); ctx.lineTo(halfL * 0.75, beam * 0.25); ctx.closePath(); ctx.fillStyle = hexToRgba(bowColor, 0.9 * (0.4 + 0.6 * dayLight)); ctx.fill();
                // Center mast dot
                ctx.beginPath(); ctx.arc(0, 0, Math.max(1.5, beam * 0.08), 0, Math.PI * 2); ctx.fillStyle = colors.accent; ctx.fill();

                // Layered wake (darker at night)
                const speedMag = Math.hypot(b.speedX || 0, b.speedY || 0);
                const speedNorm = Math.min(1, speedMag / (b.speedRef || BOAT_SPEED));
                const wakeLenScale = (0.18 + speedNorm * 0.32 + (b.tier - 1) * 0.03) * (b.wakeFactor || 1);
                const wakeWidthScale = (0.12 + speedNorm * 0.15 + (b.tier - 1) * 0.03) * (b.wakeFactor || 1);
                const wakeBrightness = 0.35 + 0.65 * dayLight;
                ctx.globalAlpha = (0.18 + (b.tier - 1) * 0.05) * wakeBrightness;
                ctx.beginPath(); ctx.moveTo(-halfL, 0); ctx.lineTo(-halfL - len * wakeLenScale, -beam * wakeWidthScale); ctx.lineTo(-halfL - len * wakeLenScale, beam * wakeWidthScale); ctx.closePath(); ctx.fillStyle = '#ffffff'; ctx.fill();
                ctx.globalAlpha = 0.12 * wakeBrightness;
                ctx.beginPath(); ctx.moveTo(-halfL, 0); ctx.lineTo(-halfL - len * wakeLenScale * 0.7, -beam * wakeWidthScale * 0.45); ctx.lineTo(-halfL - len * wakeLenScale * 0.7, beam * wakeWidthScale * 0.45); ctx.closePath();
                const wakeGrad = ctx.createLinearGradient(-halfL, 0, -halfL - len * wakeLenScale * 0.7, 0);
                wakeGrad.addColorStop(0, hexToRgba('#ffffff', 0.55 * wakeBrightness)); wakeGrad.addColorStop(1, hexToRgba('#ffffff', 0));
                ctx.fillStyle = wakeGrad; ctx.fill(); ctx.globalAlpha = 1;

                // Engine wake / paddle ripples (darker at night)
                if (['speedboat','ferry','trawler','barge'].includes(b.boatType)) {
                    ctx.globalAlpha = (0.18 + 0.25 * speedNorm) * wakeBrightness;
                    ctx.beginPath();
                    ctx.moveTo(-halfL - len * wakeLenScale * (0.10 + 0.10 * speedNorm), 0);
                    ctx.lineTo(-halfL - len * wakeLenScale * (0.45 + 0.20 * speedNorm), -beam * wakeWidthScale * (0.25 + 0.15 * speedNorm));
                    ctx.lineTo(-halfL - len * wakeLenScale * (0.45 + 0.20 * speedNorm), beam * wakeWidthScale * (0.25 + 0.15 * speedNorm));
                    ctx.closePath();
                    const engineGrad = ctx.createLinearGradient(-halfL, 0, -halfL - len * wakeLenScale * (0.45 + 0.20 * speedNorm), 0);
                    engineGrad.addColorStop(0, hexToRgba('#ffffff', 0.75 * wakeBrightness));
                    engineGrad.addColorStop(1, hexToRgba('#ffffff', 0));
                    ctx.fillStyle = engineGrad; ctx.fill();
                    ctx.globalAlpha = 1;
                } else if (b.boatType === 'kayak') {
                    ctx.globalAlpha = 0.25 * wakeBrightness;
                    for (let r = 0; r < 3; r++) {
                        ctx.beginPath();
                        ctx.arc(-halfL - r * beam * (0.5 + 0.2 * speedNorm), 0, beam * (0.3 + r * 0.22 + 0.08 * speedNorm), 0, Math.PI * 2);
                        ctx.strokeStyle = hexToRgba('#ffffff', (0.5 - r * 0.15) * wakeBrightness);
                        ctx.lineWidth = 0.9;
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                }

                ctx.restore();

                // Hitbox (reduced forward sensitivity retained)
                const hx = Math.cos(heading); const hy = Math.sin(heading);
                const hitLen = len * 0.35; const hitBeam = beam * 0.35;
                const centerShift = len * 0.20;
                const hitCenterX = x - hx * centerShift; const hitCenterY = y - hy * centerShift;
                b.screenX = hitCenterX - hitLen / 2; b.screenY = hitCenterY - hitBeam / 2; b.boxW = hitLen; b.boxH = hitBeam;
            }

            // Start at midday (offset time so cycle begins at peak daylight)
            const startOffset = DAY_NIGHT_SECONDS * 0.25; // 0.25 = noon position in cosine wave
            let last = now() + startOffset * 1000;
            
            // Initialize all boats with starting positions based on initial time
            boats.forEach(b => {
                const initialT = (now() + startOffset * 1000) / 1000;
                const initialP = (initialT % DAY_NIGHT_SECONDS) / DAY_NIGHT_SECONDS;
                const initialDayLight = 0.5 - 0.5 * Math.cos(2 * Math.PI * initialP);
                // Store initial time so boats know when they were created
                b.spawnTime = initialT;
            });
            
            // Collision detection helper - checks actual hull boundaries
            function checkCollision(boat1, boat2) {
                const dx = boat1.x - boat2.x;
                const dy = boat1.baseY - boat2.baseY;
                   // Calculate half-length and half-beam for each boat (since boats are centered)
                   const halfLen1 = boat1.len * 0.5;
                   const halfLen2 = boat2.len * 0.5;
                   const halfBeam1 = Math.max(12, boat1.len * 0.38) * 0.5;
                   const halfBeam2 = Math.max(12, boat2.len * 0.38) * 0.5;
                   // Distance needed is sum of half-sizes plus small buffer
                   const minDist = Math.max(halfLen1 + halfLen2, halfBeam1 + halfBeam2) + 10;
                const dist = Math.sqrt(dx * dx + dy * dy);
                return dist < minDist;
            }
            
            // Adjust boat positions to avoid collisions - improved algorithm
            function avoidCollisions() {
                for (let i = 0; i < boats.length; i++) {
                    for (let j = i + 1; j < boats.length; j++) {
                        const dx = boats[i].x - boats[j].x;
                        const dy = boats[i].baseY - boats[j].baseY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                           // Calculate half-sizes for each boat
                           const halfLen1 = boats[i].len * 0.5;
                           const halfLen2 = boats[j].len * 0.5;
                           const halfBeam1 = Math.max(12, boats[i].len * 0.38) * 0.5;
                           const halfBeam2 = Math.max(12, boats[j].len * 0.38) * 0.5;
                           const minDist = Math.max(halfLen1 + halfLen2, halfBeam1 + halfBeam2) + 10;
                        
                        if (dist < minDist && dist > 0) {
                            // Calculate separation force
                            const overlap = minDist - dist;
                            
                            // Normalize direction vector
                            const nx = dx / dist;
                            const ny = dy / dist;
                            
                            // Mass-proportional push: larger boats push more, move less
                            const beam1 = Math.max(12, boats[i].len * 0.38);
                            const beam2 = Math.max(12, boats[j].len * 0.38);
                            const m1 = boats[i].len * beam1;
                            const m2 = boats[j].len * beam2;
                            const totalM = m1 + m2 || 1;
                            const push = overlap;
                            // Distribute displacement inversely proportional to mass
                            const d1 = (m2 / totalM) * push; // lighter moves more
                            const d2 = (m1 / totalM) * push;
                            
                            boats[i].x += nx * d1;
                            boats[i].baseY += ny * d1;
                            boats[j].x -= nx * d2;
                            boats[j].baseY -= ny * d2;
                            
                            // No bounds clamping here - let boats move freely to respawn edges
                        }
                    }
                }
            }
            
            function tick() {
                const t = now() + startOffset * 1000;
                const dt = (t - last) / 1000; // seconds
                last = t;

                drawBackground(t / 1000);

                // Update & draw wake particles (behind boats, before drawing boats so boats appear above)
                for (let i = wakeParticles.length - 1; i >= 0; i--) {
                    const wp = wakeParticles[i];
                    wp.age += dt;
                    if (wp.age >= wp.life) { wakeParticles.splice(i,1); continue; }
                    const alpha = 1 - (wp.age / wp.life);
                    ctx.save();
                    ctx.globalAlpha = alpha * 0.35;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.ellipse(wp.x, wp.y, wp.radius * (1 + wp.age * 1.3), wp.radius * 0.6 * (1 + wp.age), 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }

                boats.forEach(b => {
                    b.x += b.speedX * dt;
                    b.baseY += b.speedY * dt;  // Update baseY instead of y for consistency
                    
                    // Respawn logic based on direction
                    let needsRespawn = false;
                    switch(b.direction) {
                        case 0: // Moving right
                            if (b.x - b.len > width + 10) needsRespawn = true;
                            break;
                        case 1: // Moving down
                            if (b.baseY - b.len > height + 10) needsRespawn = true;
                            break;
                        case 2: // Moving left
                            if (b.x + b.len < -10) needsRespawn = true;
                            break;
                        case 3: // Moving up
                            if (b.baseY + b.len < -10) needsRespawn = true;
                            break;
                    }
                    
                    if (needsRespawn) {
                        // Choose new random direction
                        b.direction = Math.floor(Math.random() * 4);

                        // Rotate boat type so all designs appear over time
                        if (typeof window.__boatCycleIndex === 'undefined') {
                            window.__boatCycleIndex = 0;
                        }
                        const ALL_BOAT_TYPES = ['sloop','catamaran','yacht','dinghy','racer','speedboat','ferry','trawler','barge','kayak'];
                        window.__boatCycleIndex = (window.__boatCycleIndex + 1) % ALL_BOAT_TYPES.length;
                        b.boatType = ALL_BOAT_TYPES[window.__boatCycleIndex];

                        // Re-randomize tier, color, and wake strength
                        const rTier = Math.random();
                        b.tier = rTier > 0.85 ? 3 : (rTier > 0.55 ? 2 : 1);
                        const palette = ['#1e90ff', '#ff7043', '#66bb6a', '#ab47bc', '#ffa726', '#29b6f6', '#ef5350', '#26a69a'];
                        b.color = palette[Math.floor(Math.random() * palette.length)];
                        b.wakeFactor = rand(0.8, 1.4);
                        b.speedRef = BOAT_SPEED * 1.6;

                        // Per-type motion profile
                        const PROFILES = {
                            sloop:      { speed: 1.00 },
                            catamaran:  { speed: 1.05 },
                            yacht:      { speed: 0.95 },
                            dinghy:     { speed: 0.85 },
                            racer:      { speed: 1.18 },
                            speedboat:  { speed: 1.32 },
                            ferry:      { speed: 0.78 },
                            trawler:    { speed: 0.75 },
                            barge:      { speed: 0.60 },
                            kayak:      { speed: 0.92 }
                        };
                        const prof = PROFILES[b.boatType] || { speed: 1 };

                        // Angle variation and wider speed range; apply profile speed factor
                        const angleVariation = rand(-0.35, 0.35); // ±20 degrees
                        const speedVariation = rand(0.6, 1.6);
                        const baseSpeed = BOAT_SPEED * speedVariation * prof.speed;

                        let baseHeading;
                        switch(b.direction) {
                            case 0: // From left, moving right
                                b.x = rand(-140, -20);
                                b.y = rand(0, height);
                                baseHeading = 0 + angleVariation;
                                b.theta = baseHeading + b.headingJitter;
                                b.speedX = Math.cos(baseHeading) * baseSpeed;
                                b.speedY = Math.sin(baseHeading) * baseSpeed;
                                break;
                            case 1: // From top, moving down
                                b.x = rand(0, width);
                                b.y = rand(-140, -20);
                                baseHeading = Math.PI / 2 + angleVariation;
                                b.theta = baseHeading + b.headingJitter;
                                b.speedX = Math.cos(baseHeading) * baseSpeed;
                                b.speedY = Math.sin(baseHeading) * baseSpeed;
                                break;
                            case 2: // From right, moving left
                                b.x = rand(width + 20, width + 160);
                                b.y = rand(0, height);
                                baseHeading = Math.PI + angleVariation;
                                b.theta = baseHeading + b.headingJitter;
                                b.speedX = Math.cos(baseHeading) * baseSpeed;
                                b.speedY = Math.sin(baseHeading) * baseSpeed;
                                break;
                            case 3: // From bottom, moving up
                                b.x = rand(0, width);
                                b.y = rand(height + 20, height + 160);
                                baseHeading = -Math.PI / 2 + angleVariation;
                                b.theta = baseHeading + b.headingJitter;
                                b.speedX = Math.cos(baseHeading) * baseSpeed;
                                b.speedY = Math.sin(baseHeading) * baseSpeed;
                                break;
                        }
                        b.baseY = b.y;
                        b.baseX = b.x;
                    }
                });
                
                // Prevent boat collisions (before drawing)
                avoidCollisions();
                
                // Draw boats and spawn wake particles
                boats.forEach(b => {
                    // Spawn wake particle at stern occasionally
                    if (Math.random() < 0.6) {
                        const sternOffset = b.len * -0.5; // stern in local coords
                        const heading = b.heading || b.theta || 0;
                        const y = b.drawY !== undefined ? b.drawY : b.baseY;
                        const sx = b.x + Math.cos(heading) * sternOffset;
                        const sy = y + Math.sin(heading) * sternOffset;
                        wakeParticles.push({
                            x: sx + rand(-1.5,1.5),
                            y: sy + rand(-1.5,1.5),
                            radius: Math.max(2.2, b.len * (b.tier === 3 ? 0.055 : b.tier === 2 ? 0.045 : 0.035)),
                            age: 0,
                            life: rand(0.8, 1.8)
                        });
                    }
                    drawBoat(b, t / 1000);
                });

                requestAnimationFrame(tick);
            }

            // Interactions
            function setTooltip(content, x, y) {
                if (!tooltip) return;
                tooltip.innerHTML = content;
                const rect = container.getBoundingClientRect();
                tooltip.style.left = `${x - rect.left}px`;
                tooltip.style.top = `${y - rect.top}px`;
                tooltip.style.display = 'block';
            }
            function hideTooltip() {
                if (tooltip) tooltip.style.display = 'none';
            }
            function hitTest(mx, my) {
                // Rotated rectangle hit test using boat's heading
                for (let i = boats.length - 1; i >= 0; i--) {
                    const b = boats[i];
                    if (!b) continue;
                    const len = b.len;
                    // Narrower lateral hitbox to reduce "side" sensitivity (reduced from 0.20 to 0.15)
                    const beam = Math.max(5, len * 0.15);
                    const heading = b.heading || b.theta || 0;
                    const y = b.drawY !== undefined ? b.drawY : b.baseY;
                    const dx = mx - b.x;
                    const dy = my - y;
                    const cosH = Math.cos(-heading);
                    const sinH = Math.sin(-heading);
                    // Rotate point into boat local space
                    const rx = dx * cosH - dy * sinH;
                    const ry = dx * sinH + dy * cosH;
                    // Reduced hitbox: use 70% of length (was full length)
                    if (rx >= -len*0.35 && rx <= len*0.35 && ry >= -beam/2 && ry <= beam/2) {
                        return b;
                    }
                }
                return null;
            }

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                let hovered = false;
                const b = hitTest(mx, my);
                boats.forEach(boat => boat.hover = false);
                if (b) {
                    b.hover = true;
                    hovered = true;
                    canvas.style.cursor = 'pointer';
                    const speed = Math.hypot(b.speedX || 0, b.speedY || 0);
                    setTooltip(`${b.boatType.toUpperCase()} — Speed ${Math.round(speed)}`, e.clientX, e.clientY);
                } else {
                    canvas.style.cursor = 'default';
                    hideTooltip();
                }
            });
            canvas.addEventListener('mouseleave', hideTooltip);
            canvas.addEventListener('click', (e) => {
                // No product navigation — boats are decorative now
                return;
            });


            requestAnimationFrame(tick);
        })();
    </script>
    
    <script>
        // Weather Widget - Uses OpenWeatherMap free API
        const apiKey = '519386db5aaeba4964ff7ee4f20c0a42';
        
        // Map variables
        let locationMap = null;
        let mapMarker = null;
        let selectedLocation = null;
        
        async function loadWeather(lat = null, lon = null, cityName = null) {
            try {
                // Get saved location or use default
                const savedLocation = localStorage.getItem('weatherLocation');
                if (!lat && !lon && savedLocation) {
                    const saved = JSON.parse(savedLocation);
                    lat = saved.lat;
                    lon = saved.lon;
                    cityName = saved.name;
                }
                
                // Default to a coastal sailing location (Sydney, Australia)
                if (!lat || !lon) {
                    lat = -33.8688;
                    lon = 151.2093;
                    cityName = cityName || 'Sydney Harbour';
                }
                
                // Fetch real weather data
                const response = await fetch(
                    `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric`
                );
                const data = await response.json();
                
                // Save location
                localStorage.setItem('weatherLocation', JSON.stringify({
                    lat: lat,
                    lon: lon,
                    name: data.name || cityName
                }));
                
                // Update UI
                document.getElementById('weather-temp').textContent = `${Math.round(data.main.temp)}°C`;
                document.getElementById('weather-wind').textContent = `${Math.round(data.wind.speed)} knots`;
                document.getElementById('weather-condition').textContent = data.weather[0].main;
                document.getElementById('weather-location').textContent = data.name || cityName;
                
                // Determine sailing conditions
                const windSpeed = data.wind.speed;
                const badge = document.getElementById('sailing-condition-badge');
                
                if (windSpeed < 5) {
                    badge.textContent = 'Light Winds';
                    badge.className = 'badge bg-warning';
                } else if (windSpeed < 15) {
                    badge.textContent = 'Good Sailing';
                    badge.className = 'badge bg-success';
                } else if (windSpeed < 25) {
                    badge.textContent = 'Strong Winds';
                    badge.className = 'badge bg-info';
                } else {
                    badge.textContent = 'Gale Warning';
                    badge.className = 'badge bg-danger';
                }
                
                // Update weather icon
                const icon = document.getElementById('weather-icon');
                const condition = data.weather[0].main.toLowerCase();
                if (condition.includes('clear')) {
                    icon.textContent = '☀️';
                } else if (condition.includes('cloud')) {
                    icon.textContent = '⛅';
                } else if (condition.includes('rain')) {
                    icon.textContent = '🌧️';
                } else if (condition.includes('storm')) {
                    icon.textContent = '⛈️';
                } else {
                    icon.textContent = '⛵';
                }
                
            } catch (error) {
                console.error('Weather API error:', error);
                // Show fallback demo data
                document.getElementById('weather-temp').textContent = '22°C';
                document.getElementById('weather-wind').textContent = '12 knots';
                document.getElementById('weather-condition').textContent = 'Clear';
                document.getElementById('weather-location').textContent = 'Demo Location';
                document.getElementById('weather-icon').textContent = '☀️';
                document.getElementById('sailing-condition-badge').textContent = 'Good Sailing';
                document.getElementById('sailing-condition-badge').className = 'badge bg-success';
            }
        }
        
        // Initialize map when modal is shown
        function showLocationModal() {
            const modal = new bootstrap.Modal(document.getElementById('locationModal'));
            modal.show();
            
            // Initialize map after modal is shown
            setTimeout(() => {
                if (!locationMap) {
                    // Create map centered on world view
                    locationMap = L.map('locationMap').setView([20, 0], 2);
                    
                    // Add OpenStreetMap tiles (reverted from satellite)
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; OpenStreetMap contributors',
                        maxZoom: 18
                    }).addTo(locationMap);
                    
                    // Add click event to map
                    locationMap.on('click', async function(e) {
                        const lat = e.latlng.lat;
                        const lon = e.latlng.lng;
                        
                        // Remove existing marker
                        if (mapMarker) {
                            locationMap.removeLayer(mapMarker);
                        }
                        
                        // Add new marker
                        mapMarker = L.marker([lat, lon]).addTo(locationMap);
                        
                        // Get location name via reverse geocoding
                        try {
                            const response = await fetch(`https://api.openweathermap.org/geo/1.0/reverse?lat=${lat}&lon=${lon}&limit=1&appid=${apiKey}`);
                            const data = await response.json();
                            const locationName = data.length > 0 ? `${data[0].name}, ${data[0].country}` : 'Selected Location';
                            
                            mapMarker.bindPopup(locationName).openPopup();
                            
                            // Store selected location
                            selectedLocation = {
                                lat: lat,
                                lon: lon,
                                name: data.length > 0 ? data[0].name : 'Custom Location'
                            };
                            
                            // Update info display
                            document.getElementById('selectedLocationName').textContent = locationName;
                            document.getElementById('selectedLat').textContent = lat.toFixed(4);
                            document.getElementById('selectedLon').textContent = lon.toFixed(4);
                            document.getElementById('locationInfo').style.display = 'block';
                            document.getElementById('setLocationBtn').disabled = false;
                            
                        } catch (error) {
                            console.error('Reverse geocoding failed:', error);
                            mapMarker.bindPopup(`Lat: ${lat.toFixed(4)}, Lon: ${lon.toFixed(4)}`).openPopup();
                            
                            selectedLocation = {
                                lat: lat,
                                lon: lon,
                                name: 'Selected Location'
                            };
                            
                            document.getElementById('setLocationBtn').disabled = false;
                        }
                    });
                } else {
                    // Refresh map size if already initialized
                    locationMap.invalidateSize();
                }
            }, 300);
        }
        
        // Search for location by city name
        async function searchLocation() {
            const cityInput = document.getElementById('citySearch');
            const cityName = cityInput.value.trim();
            const errorDiv = document.getElementById('locationError');
            
            errorDiv.style.display = 'none';
            
            if (!cityName) {
                errorDiv.textContent = 'Please enter a city or marina name';
                errorDiv.style.display = 'block';
                return;
            }
            
            try {
                const response = await fetch(`https://api.openweathermap.org/geo/1.0/direct?q=${encodeURIComponent(cityName)}&limit=1&appid=${apiKey}`);
                const data = await response.json();
                
                if (data.length === 0) {
                    errorDiv.textContent = 'Location not found. Try a different city or marina name.';
                    errorDiv.style.display = 'block';
                    return;
                }
                
                const location = data[0];
                
                // Update map view
                locationMap.setView([location.lat, location.lon], 10);
                
                // Remove existing marker
                if (mapMarker) {
                    locationMap.removeLayer(mapMarker);
                }
                
                // Add marker
                mapMarker = L.marker([location.lat, location.lon]).addTo(locationMap);
                mapMarker.bindPopup(`${location.name}, ${location.country}`).openPopup();
                
                // Store selected location
                selectedLocation = {
                    lat: location.lat,
                    lon: location.lon,
                    name: location.name
                };
                
                // Update info display
                document.getElementById('selectedLocationName').textContent = `${location.name}, ${location.country}`;
                document.getElementById('selectedLat').textContent = location.lat.toFixed(4);
                document.getElementById('selectedLon').textContent = location.lon.toFixed(4);
                document.getElementById('locationInfo').style.display = 'block';
                document.getElementById('setLocationBtn').disabled = false;
                
            } catch (error) {
                errorDiv.textContent = 'Failed to search location. Please try again.';
                errorDiv.style.display = 'block';
            }
        }
        
        // Quick location buttons
        function quickLocation(name, lat, lon) {
            // Update map view
            locationMap.setView([lat, lon], 10);
            
            // Remove existing marker
            if (mapMarker) {
                locationMap.removeLayer(mapMarker);
            }
            
            // Add marker
            mapMarker = L.marker([lat, lon]).addTo(locationMap);
            mapMarker.bindPopup(name).openPopup();
            
            // Store selected location
            selectedLocation = {
                lat: lat,
                lon: lon,
                name: name
            };
            
            // Update info display
            document.getElementById('selectedLocationName').textContent = name;
            document.getElementById('selectedLat').textContent = lat.toFixed(4);
            document.getElementById('selectedLon').textContent = lon.toFixed(4);
            document.getElementById('locationInfo').style.display = 'block';
            document.getElementById('setLocationBtn').disabled = false;
        }
        
        // Use browser's geolocation
        function useCurrentLocation() {
            const errorDiv = document.getElementById('locationError');
            errorDiv.style.display = 'none';
            
            if (!navigator.geolocation) {
                errorDiv.textContent = 'Geolocation is not supported by your browser';
                errorDiv.style.display = 'block';
                return;
            }
            
            // Show loading state
            const geoBtn = document.querySelector('[onclick="useCurrentLocation()"]');
            const originalText = geoBtn.innerHTML;
            geoBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Getting location...';
            geoBtn.disabled = true;
            
            navigator.geolocation.getCurrentPosition(
                async (position) => {
                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    
                    try {
                        // Update map view
                        locationMap.setView([lat, lon], 12);
                        
                        // Remove existing marker
                        if (mapMarker) {
                            locationMap.removeLayer(mapMarker);
                        }
                        
                        // Add marker
                        mapMarker = L.marker([lat, lon]).addTo(locationMap);
                        
                        // Get city name from coordinates
                        const response = await fetch(`https://api.openweathermap.org/geo/1.0/reverse?lat=${lat}&lon=${lon}&limit=1&appid=${apiKey}`);
                        const data = await response.json();
                        
                        const cityName = data.length > 0 ? data[0].name : 'Current Location';
                        const displayName = data.length > 0 ? `${data[0].name}, ${data[0].country}` : 'Your Current Location';
                        
                        mapMarker.bindPopup(displayName).openPopup();
                        
                        // Store selected location
                        selectedLocation = {
                            lat: lat,
                            lon: lon,
                            name: cityName
                        };
                        
                        // Update info display
                        document.getElementById('selectedLocationName').textContent = displayName;
                        document.getElementById('selectedLat').textContent = lat.toFixed(4);
                        document.getElementById('selectedLon').textContent = lon.toFixed(4);
                        document.getElementById('locationInfo').style.display = 'block';
                        document.getElementById('setLocationBtn').disabled = false;
                        
                    } catch (error) {
                        errorDiv.textContent = 'Failed to get location details. Please try again.';
                        errorDiv.style.display = 'block';
                    } finally {
                        // Restore button state
                        geoBtn.innerHTML = originalText;
                        geoBtn.disabled = false;
                    }
                },
                (error) => {
                    let message = 'Unable to get your location. ';
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            message += 'Please enable location permissions.';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            message += 'Location information unavailable.';
                            break;
                        case error.TIMEOUT:
                            message += 'Location request timed out.';
                            break;
                        default:
                            message += 'Please try again.';
                    }
                    errorDiv.textContent = message;
                    errorDiv.style.display = 'block';
                    
                    // Restore button state
                    geoBtn.innerHTML = originalText;
                    geoBtn.disabled = false;
                }
            );
        }
        
        // Confirm and apply selected location
        async function confirmLocation() {
            if (!selectedLocation) return;
            
            await loadWeather(selectedLocation.lat, selectedLocation.lon, selectedLocation.name);
            
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('locationModal'));
            modal.hide();
            
            // Reset modal state
            document.getElementById('citySearch').value = '';
            document.getElementById('locationError').style.display = 'none';
            document.getElementById('locationInfo').style.display = 'none';
            document.getElementById('setLocationBtn').disabled = true;
        }
        
        // Allow Enter key to search
        document.getElementById('citySearch').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchLocation();
            }
        });
        
        // Load weather on page load
        // loadWeather();
        
        // Refresh every 15 minutes
        // setInterval(loadWeather, 15 * 60 * 1000);
    </script>
</body>
</html>